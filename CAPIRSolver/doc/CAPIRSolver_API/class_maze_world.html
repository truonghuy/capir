<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CAPIRSolver: MazeWorld Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sheep-icon-normal.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CAPIRSolver&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">API documentation of CAPIRSolver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_maze_world.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>MazeWorld Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MazeWorld" --><!-- doxytag: inherits="Model" -->
<p>This class is the base class for a game's level in which the protagonists need to solve puzzles to pass.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_maze_world_8h_source.html">MazeWorld.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MazeWorld:</div>
<div class="dyncontent">
<div class="center"><img src="class_maze_world__inherit__graph.png" border="0" usemap="#_maze_world_inherit__map" alt="Inheritance graph"/></div>
<map name="_maze_world_inherit__map" id="_maze_world_inherit__map">
<area shape="rect" id="node5" href="class_ghost_busters_level.html" title="GhostBustersLevel" alt="" coords="5,161,141,189"/><area shape="rect" id="node2" href="class_model.html" title="Base class for MDP models." alt="" coords="44,6,103,34"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MazeWorld:</div>
<div class="dyncontent">
<div class="center"><img src="class_maze_world__coll__graph.png" border="0" usemap="#_maze_world_coll__map" alt="Collaboration graph"/></div>
<map name="_maze_world_coll__map" id="_maze_world_coll__map">
<area shape="rect" id="node10" href="class_player.html" title="Base class of individual game&#39;s Human and AiAssistant." alt="" coords="93,353,155,381"/><area shape="rect" id="node2" href="class_model.html" title="Base class for MDP models." alt="" coords="188,166,247,194"/><area shape="rect" id="node4" href="struct_augmented_state.html" title="AugmentedState" alt="" coords="271,166,393,194"/><area shape="rect" id="node6" href="struct_state.html" title="State" alt="" coords="305,86,359,114"/><area shape="rect" id="node8" href="class_stats.html" title="Stats\&lt; State \&gt;" alt="" coords="277,6,387,34"/><area shape="rect" id="node12" href="class_agent.html" title="Base class of Monster and HumanAssistant." alt="" coords="52,259,108,287"/><area shape="rect" id="node14" href="class_object_with_properties.html" title="This class defines objects with properties and able to react." alt="" coords="5,166,155,194"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_maze_world-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a9053a78e16e6bba79d2a5c80e7788f71">MazeWorld</a> (<a class="el" href="struct_maze_world_description.html">MazeWorldDescription</a> &amp;desc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a328c7d35892221fc7bc41fced09ef78c">realDynamics</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, long player0Act, long player1Act, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; int &gt; &amp;succeedArray, vector&lt; int &gt; &amp;terminalArray, vector&lt; long &gt; &amp;monsterActions, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#af208f1a60114068b493fd7472d5a3328">sample</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;humanAct, long &amp;aiAct, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; long &gt; &amp;monsterActions, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ae92362afe4641c949fb7d64ba189303f">moveState</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long player0Act, long player1Act, int playerIndex, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; long &gt; &amp;monsterActions, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a6e8c361ad7dc7ab591cb0dc606849319">realToVirtual</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, const long worldNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a64a803b3dada43e54c795078d5705610">actionFromChar</a> (const char c, int &amp;humanOrAi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#af3fd1481deb76cfa7fbb39e8bf2562a9">getCompoundAct</a> (long playerAct, int playerIndex, long aiAct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af857e2a7e434e8345163d6d49311fd47"></a><!-- doxytag: member="MazeWorld::containsAgentAction" ref="af857e2a7e434e8345163d6d49311fd47" args="(long compoundAct, long playerAct, int playerIndex)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>containsAgentAction</b> (long compoundAct, long playerAct, int playerIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a71095018856a59ebbe07529603d824d2">writeSolution</a> (string filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#aaf45b03e2c29c45285ca601e56a0823a">readSolution</a> (string filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#afb01c3fca78cb5a9251d9378f9635379">~MazeWorld</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a84a123d52de638129023d1a0418c9495">initializeHumanAssistantMazes</a> (<a class="el" href="struct_maze_world_description.html">MazeWorldDescription</a> &amp;desc)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ad8a1bca5cb6e468450d00c7d8099dcc5">setDefaultVisionLimit</a> (double visLim)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#af5460232c8e15a87ecc70e0b6c33c9df">setUseAbstract</a> (bool uA)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#afb7de284612b7d0ecc28601a5182b9ef">worldInitialize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ab50460352527c757108d6acf05f86558">getTopology</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a41e5802bafd08420e24a40a1f16a7188">generateStateMap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a3e8cb2bd31df3c5b6e986ce896d5f0ca">generateModel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a09f6e0dfe61c250fdb7a2130ba6d9dad">getWorldRepresentation</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a45f9066eaf97820d58b9a782705eac0a">getWorldRepresentationXML</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a220829ac4eb9ace9c1d4e7f77e9d90a4">isBlockedAt</a> (const <a class="el" href="struct_state.html">State</a> *state, long x, long y, long &amp;monsterNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a784453673bdce371b26fbf5b36455e2c">isValidMonsterMove</a> (<a class="el" href="class_monster.html">Monster</a> *monster, long monsterX, long monsterY, const <a class="el" href="struct_state.html">State</a> *currState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a137d5176008d0ad413eb2d50755c764a">isValidMove</a> (long tempX, long tempY, long currAgentX, long currAgentY, const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; int &gt; *succeedArray=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a5b39300aececdf9c510d16ad1ea90de0">printGrid</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a25a30ab0784899d5588fbd213ce10bbe">displayState</a> (const <a class="el" href="struct_state.html">State</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#aa3b206f0451bc8b7a350e4cef987086a">hasMonster</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, long x, long y, string monsterName=&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ab72b9362f9a3ab8d4933bd57b2b259a9">getPlayerString</a> (int playerIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a9abacdc3ef9d5c26370e827510f8cb6e">getPlayerStringXML</a> (int playerIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a9f57ae8aec5b7d79a73dfc44e6841f99">getNumAliveWorlds</a> (const <a class="el" href="struct_state.html">State</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a5f08af847a4bb7620e3edafed7b7cb22">getDeadWorlds</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, std::vector&lt; long &gt; &amp;deadWorlds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d77e8be251d206592c3ed95e95b9665"></a><!-- doxytag: member="MazeWorld::getAliveWorlds" ref="a1d77e8be251d206592c3ed95e95b9665" args="(const State &amp;state, std::vector&lt; long &gt; &amp;aliveWorlds)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>getAliveWorlds</b> (const <a class="el" href="struct_state.html">State</a> &amp;state, std::vector&lt; long &gt; &amp;aliveWorlds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a4483788d58851d971a85675d0acc5392">getSubworldAliveStatus</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, std::vector&lt; bool &gt; &amp;aliveStatus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a230c33bc04c02695f4cc5ab225436e43">negativeInteract</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, long i, long j)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a31ae4adb74ed80ae629562a2addeb413">gotInteraction</a> (const <a class="el" href="struct_state.html">State</a> &amp;state)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#acde128844c14b2e019e1b61a2f4658d7">getValidCompoundActions</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, vector&lt; long &gt; &amp;validActions, long playerAction=-1, int playerIndex=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a357d748113ae76399986121386a5f57e">getCurrState</a> (<a class="el" href="struct_state.html">State</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ac58a1d772b7d862e4c541eab63cd2a9c">getRandomizedState</a> (<a class="el" href="struct_state.html">State</a> &amp;state, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a04c4312f522f78bb08ddf919f5cd1299">getRandomizedGrid</a> (long &amp;x, long &amp;y, std::vector&lt; long &gt; &amp;occupiedGrids, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a7649a247ddf42879cea52b21ad4cfb8f">isTermState</a> (const <a class="el" href="struct_state.html">State</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd489e9b3d20e86e5e24b9a60736b68e"></a><!-- doxytag: member="MazeWorld::someWorldAlive" ref="abd489e9b3d20e86e5e24b9a60736b68e" args="(const State &amp;state)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>someWorldAlive</b> (const <a class="el" href="struct_state.html">State</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ac1af92861c0f563f65d632f8db72ef63">hasOneSubworldAlive</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#afa1b8bafe64e93ed4eb6c92efb946f04">getBestCompoundAct</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;bestCompoundAct, long playerAct=-1, int playerIndex=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ac72839a717373011ee2bb91983d7fd1a">getBestCompoundActInSubworld</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, int subWorld, long playerAct, int playerIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a40fde4d3c9a25c5922778b6fe05fa18d">getBestCompoundActionsInSubtasks</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, std::vector&lt; std::vector&lt; long &gt; &gt; &amp;bestCompoundActions, double tolerance, long playerAct, int playerIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5b09b616c7b197acfd27d69892b9a3"></a><!-- doxytag: member="MazeWorld::getQValue" ref="aef5b09b616c7b197acfd27d69892b9a3" args="(const State &amp;currState, const vector&lt; double &gt; &amp;wBelief, const long compoundAct)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>getQValue</b> (const <a class="el" href="struct_state.html">State</a> &amp;currState, const vector&lt; double &gt; &amp;wBelief, const long compoundAct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a5a7d847278a8d592f6afb8ef3818e4b2">getQValues</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, vector&lt; pair&lt; long, double &gt; &gt; &amp;QValues, long playerAct=-1, int playerIndex=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a9ff2440f157082285088a02a5323bc8a">rewardFromRealDynamics</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long player0Act, long player1Act, int playerIndex, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; vector&lt; double &gt; &gt; &amp;condProbAct, vector&lt; long &gt; &amp;monsterActions, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a2a42d9a180772b2a89e9992476bcd471">executeAgentActions</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, long player0Act, long player1Act, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; int &gt; &amp;succeedArray, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a89b34a8e39e4ebf4de4d5d2c395e5b37">policy</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;p1act, long &amp;p2act, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; long &gt; &amp;monsterActions, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a777ba7c0ca6110fd995bea65d2f8df4d"></a><!-- doxytag: member="MazeWorld::policy_stupidAI" ref="a777ba7c0ca6110fd995bea65d2f8df4d" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;p1act, long &amp;p2act, State &amp;nextState, vector&lt; long &gt; &amp;monsterActions, RandSource &amp;randSource, int scriptMode=0)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>policy_stupidAI</b> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;p1act, long &amp;p2act, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; long &gt; &amp;monsterActions, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource, int scriptMode=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb788bc3daf0b697467f82a53de7f308"></a><!-- doxytag: member="MazeWorld::policyHuman" ref="aeb788bc3daf0b697467f82a53de7f308" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long playerAct, int playerIndex, long &amp;aiAct, State &amp;nextState, vector&lt; long &gt; &amp;monsterActions, RandSource &amp;randSource)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>policyHuman</b> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long playerAct, int playerIndex, long &amp;aiAct, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; long &gt; &amp;monsterActions, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a601eca91dd91699fcdfded87fc708ab1">policyHuman_stupidAI</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long playerAct, int playerIndex, long &amp;aiAct, <a class="el" href="struct_state.html">State</a> &amp;nextState, vector&lt; long &gt; &amp;monsterActions, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource, int scriptMode=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ac8d64ab17756316122f4736b3d1ca664">policyRoutine</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;bestAiAct, long playerAct, int playerIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a45a204bae5f95b844d11e15512e55c09">applyMonsterMoveAct</a> (<a class="el" href="struct_state.html">State</a> &amp;state, long act, int worldNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#acbb72a615c2e69496db99d3b6129102b">stateToPosChar</a> (const <a class="el" href="struct_augmented_state.html">AugmentedState</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a64c50a5c4fe02ecca4aa0b66863c7cfc">stateToPosCharXML</a> (const <a class="el" href="struct_augmented_state.html">AugmentedState</a> &amp;state, const int timeStamp=-2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10f0af2dc6453629103edd0871836f57"></a><!-- doxytag: member="MazeWorld::stateToXMLDoc" ref="a10f0af2dc6453629103edd0871836f57" args="(pugi::xml_document &amp;doc, const AugmentedState &amp;state, const int timeStamp=&#45;2)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>stateToXMLDoc</b> (<a class="el" href="classpugi_1_1xml__document.html">pugi::xml_document</a> &amp;doc, const <a class="el" href="struct_augmented_state.html">AugmentedState</a> &amp;state, const int timeStamp=-2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ada8facde539f034b72b3de4e404d620e">getReward</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, bool &amp;terminal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a7b4e4022e7c2cc2616cb7f3375283cfa">getMaxReward</a> (const <a class="el" href="struct_state.html">State</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a8777d7082bd0512455a30a8b4be9086c">getMinReward</a> (const <a class="el" href="struct_state.html">State</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a514d169c5b86496dbf7da60d0a9e62ba"></a><!-- doxytag: member="MazeWorld::getVmax" ref="a514d169c5b86496dbf7da60d0a9e62ba" args="(const State *state)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>getVmax</b> (const <a class="el" href="struct_state.html">State</a> *state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c399e091b1e1717ae10eddc63db7fda"></a><!-- doxytag: member="MazeWorld::getVmin" ref="a8c399e091b1e1717ae10eddc63db7fda" args="(const State *state)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>getVmin</b> (const <a class="el" href="struct_state.html">State</a> *state)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a234218d45222dea42165110a4e1c72dd">readDescriptionFromTMXFile</a> (string filename, <a class="el" href="class_game_tile_sheet.html">GameTileSheet</a> &amp;gts, <a class="el" href="struct_maze_world_description.html">MazeWorldDescription</a> &amp;desc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a45339a36ecb6545ccdbf314386d652bd">detectRegionsInGrid</a> (long <a class="el" href="class_maze_world.html#a77ff69eb37ab72e44da066149d8082d1">xSize</a>, long ySize, vector&lt; vector&lt; long &gt; &gt; &amp;<a class="el" href="class_maze_world.html#a971cb8af34ba380d3d0be5b1ee3a9e6d">grid</a>, long startingJuncIndex)</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_player.html">Player</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a3d9fe13eed4cdb76351c42b59718368e">player</a> [2]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_maze.html">Maze</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ad5e853b690e4594b55b3b83dda6c1151">mazes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a35bf9df51329fac0286dc94de8f4c603">numWorlds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utilities.html#a30ae08a60e405d53094bec28df74ba7a">Utilities::goalType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a8aeb5c1eae4d74443383a0eece6269b6">gType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a3959bfff171aec5dc1b988338ff689c8">equivWorlds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a36a83f5fbb99b45153a0332b69a1487b">visionLimit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b09cf029a5dcb3ac3d7f584e2a12e89"></a><!-- doxytag: member="MazeWorld::monsterBlock" ref="a6b09cf029a5dcb3ac3d7f584e2a12e89" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>monsterBlock</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ad4d3258814fe3a748105837917b4f6ab">agentBlock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a56ae73470aac1d75379ad18428877add">numRegionPerAgent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a77ff69eb37ab72e44da066149d8082d1">xSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7a952a5edc977d47c61450e40c0d124"></a><!-- doxytag: member="MazeWorld::ySize" ref="af7a952a5edc977d47c61450e40c0d124" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>ySize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a971cb8af34ba380d3d0be5b1ee3a9e6d">grid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#ae375e48cfcf71826f10dcb6259f9f651">targetPrecision</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a5c16ab97f494d794c929863c7168a7c0">displayInterval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a02167c7ca4d0cd5984feed998f0fbb6c">gridNodeLabel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dae18739b96b4dfb14c571d72ad04d5"></a><!-- doxytag: member="MazeWorld::reverseGridNodeLabel" ref="a2dae18739b96b4dfb14c571d72ad04d5" args="" -->
vector&lt; pair&lt; long, long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverseGridNodeLabel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a94bbfb19123761d2ad660d626e83132f">numAccessibleLocs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a47c07595f07a1347f5e11a8c543bd613">connectivity</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a78a71b1f3e46d87fe3deebe7e505a460">borderLength</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; long, long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#aa21b75766ff6d1defa5a388584082ead">regionRepPoint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; regionType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#a298453db5e208f50311a4444df12e665">rType</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_augmented_state.html">AugmentedState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze_world.html#abdb160e5fc085a5e6d84e59834c541ac">lastState</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class is the base class for a game's level in which the protagonists need to solve puzzles to pass. </p>
<p>This class holds</p>
<ul>
<li>References to the players and geometrical data, used for in-game dynamics.</li>
<li>References to all individual Maze's, each of which contains references to at most one <a class="el" href="class_monster.html" title="Base class of all NPCs.">Monster</a>. Note that in this new version, human = player[0], assistant = player[1]</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Truong Huy Nguyen </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>December 2010 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9053a78e16e6bba79d2a5c80e7788f71"></a><!-- doxytag: member="MazeWorld::MazeWorld" ref="a9053a78e16e6bba79d2a5c80e7788f71" args="(MazeWorldDescription &amp;desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MazeWorld::MazeWorld </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_maze_world_description.html">MazeWorldDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor. <a class="el" href="struct_maze_world_description.html">MazeWorldDescription</a> provides initialization for all parameters. </p>

</div>
</div>
<a class="anchor" id="afb01c3fca78cb5a9251d9378f9635379"></a><!-- doxytag: member="MazeWorld::~MazeWorld" ref="afb01c3fca78cb5a9251d9378f9635379" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MazeWorld::~MazeWorld </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate resources assigned. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a64a803b3dada43e54c795078d5705610"></a><!-- doxytag: member="MazeWorld::actionFromChar" ref="a64a803b3dada43e54c795078d5705610" args="(const char c, int &amp;humanOrAi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MazeWorld::actionFromChar </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>humanOrAi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For customized control, inherited class should change this routine.</p>
<p>Action map from input keystroke. In this game, there are five actions: w = up s = down a = left d = right anything else = no move</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>the input character keystroke. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">humanOrAi</td><td>if set (playerIndex), this tells the routine to interprete c as the respective playerIndex's action. Otherwise, the routine will try to map c to human's action first, assistant's second and set humanOrAi to the respective mapped playerIndex. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_model.html">Model</a>.</p>

</div>
</div>
<a class="anchor" id="a45a204bae5f95b844d11e15512e55c09"></a><!-- doxytag: member="MazeWorld::applyMonsterMoveAct" ref="a45a204bae5f95b844d11e15512e55c09" args="(State &amp;state, long act, int worldNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::applyMonsterMoveAct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>worldNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Applies the monster's move action on <em>state</em>. The validity of act was already checked in getAct* routines of <a class="el" href="class_monster.html" title="Base class of all NPCs.">Monster</a>. Additional check can be carried out in extending classes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Current <a class="el" href="struct_state.html">State</a> to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">act</td><td>Monster's action to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">worldNum</td><td>the Monster's world index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45339a36ecb6545ccdbf314386d652bd"></a><!-- doxytag: member="MazeWorld::detectRegionsInGrid" ref="a45339a36ecb6545ccdbf314386d652bd" args="(long xSize, long ySize, vector&lt; vector&lt; long &gt; &gt; &amp;grid, long startingJuncIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MazeWorld::detectRegionsInGrid </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>xSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>startingJuncIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mark regions in the map of form &lt;0,1&gt;. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSize</td><td>num cols </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ySize</td><td>num rows </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grid</td><td>the map to be marked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startingJuncIndex</td><td>starting numeric index of junctions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25a30ab0784899d5588fbd213ce10bbe"></a><!-- doxytag: member="MazeWorld::displayState" ref="a25a30ab0784899d5588fbd213ce10bbe" args="(const State &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::displayState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print state with grid in ASCII </p>

<p>Reimplemented in <a class="el" href="class_ghost_busters_level.html#a4fe77e5d3cd3da0f9f7e1e8c8e13fed7">GhostBustersLevel</a>.</p>

</div>
</div>
<a class="anchor" id="a2a42d9a180772b2a89e9992476bcd471"></a><!-- doxytag: member="MazeWorld::executeAgentActions" ref="a2a42d9a180772b2a89e9992476bcd471" args="(const State &amp;currState, long player0Act, long player1Act, State &amp;nextState, vector&lt; int &gt; &amp;succeedArray, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::executeAgentActions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>player0Act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>player1Act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>succeedArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Applies agents' actions on currState to produce nextState.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>Current <a class="el" href="struct_state.html">State</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">player0Act</td><td>Index of Human action to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">player1Act</td><td>Index of AiAssistant action to perform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nextState</td><td>Sampled next state. This is random and changes from invocation to invocation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">succeedArray</td><td>stores value of 1 or 0 for each of the Maze's. 1 means the move is valid in that world, 0 means the move is invalid in that world. This info hints the assistant on which world is the blocking world. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">randSource</td><td>Source of random numbers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8cb2bd31df3c5b6e986ce896d5f0ca"></a><!-- doxytag: member="MazeWorld::generateModel" ref="a3e8cb2bd31df3c5b6e986ce896d5f0ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::generateModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invokes corresponding function of Maze's. This computes the V and Q functions. </p>

</div>
</div>
<a class="anchor" id="a41e5802bafd08420e24a40a1f16a7188"></a><!-- doxytag: member="MazeWorld::generateStateMap" ref="a41e5802bafd08420e24a40a1f16a7188" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::generateStateMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invokes corresponding function of Maze's. Each original world stores its own class state map, which would then be copied over by worlds of the same type.</p>
<p>This routine generates state map. Depending on the useAbstract property, each maze will generate corresponding state map. </p>

</div>
</div>
<a class="anchor" id="afa1b8bafe64e93ed4eb6c92efb946f04"></a><!-- doxytag: member="MazeWorld::getBestCompoundAct" ref="afa1b8bafe64e93ed4eb6c92efb946f04" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;bestCompoundAct, long playerAct=&#45;1, int playerIndex=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::getBestCompoundAct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>bestCompoundAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>playerAct</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the best compound action in <em>bestCompoundAct</em> given current state <em>currState</em> and current world belief <em>wBelief</em>, together with corresponding belief-weighted Q value. </p>

</div>
</div>
<a class="anchor" id="ac72839a717373011ee2bb91983d7fd1a"></a><!-- doxytag: member="MazeWorld::getBestCompoundActInSubworld" ref="ac72839a717373011ee2bb91983d7fd1a" args="(const State &amp;currState, int subWorld, long playerAct, int playerIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MazeWorld::getBestCompoundActInSubworld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subWorld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>playerAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the best compound act in subworld <em>subWorld</em>, which has <em>playerAct</em> as part of it. </p>

</div>
</div>
<a class="anchor" id="a40fde4d3c9a25c5922778b6fe05fa18d"></a><!-- doxytag: member="MazeWorld::getBestCompoundActionsInSubtasks" ref="a40fde4d3c9a25c5922778b6fe05fa18d" args="(const State &amp;currState, std::vector&lt; std::vector&lt; long &gt; &gt; &amp;bestCompoundActions, double tolerance, long playerAct, int playerIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::getBestCompoundActionsInSubtasks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bestCompoundActions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>playerAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>bestCompoundActions stores the best compound actions in each of the subworlds. </p>

</div>
</div>
<a class="anchor" id="af3fd1481deb76cfa7fbb39e8bf2562a9"></a><!-- doxytag: member="MazeWorld::getCompoundAct" ref="af3fd1481deb76cfa7fbb39e8bf2562a9" args="(long playerAct, int playerIndex, long aiAct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MazeWorld::getCompoundAct </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>playerAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>aiAct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the compound action given <em>playerAct</em> and <em>aiAct</em> </dd></dl>
<p>If <em>playerAct</em> is not furnished, it is assumed to be zero. </p>

</div>
</div>
<a class="anchor" id="a357d748113ae76399986121386a5f57e"></a><!-- doxytag: member="MazeWorld::getCurrState" ref="a357d748113ae76399986121386a5f57e" args="(State &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::getCurrState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke corresponding routines in human, assistant and mazes to fill the raw state with respective info.</p>
<p>Invoke corresponding routines in player[0], player[1] and mazes to fill the raw state with respective info. </p>

<p>Implements <a class="el" href="class_model.html">Model</a>.</p>

</div>
</div>
<a class="anchor" id="a5f08af847a4bb7620e3edafed7b7cb22"></a><!-- doxytag: member="MazeWorld::getDeadWorlds" ref="a5f08af847a4bb7620e3edafed7b7cb22" args="(const State &amp;state, std::vector&lt; long &gt; &amp;deadWorlds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::getDeadWorlds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>deadWorlds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the list of dead worlds </p>

</div>
</div>
<a class="anchor" id="a7b4e4022e7c2cc2616cb7f3375283cfa"></a><!-- doxytag: member="MazeWorld::getMaxReward" ref="a7b4e4022e7c2cc2616cb7f3375283cfa" args="(const State &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::getMaxReward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get maximum reward achievable in one time step</p>
<p>Based on state, get the max reward of individual mazes, sum them up. Assumption: Mazes do not interact to give more rewards. </p>

</div>
</div>
<a class="anchor" id="a8777d7082bd0512455a30a8b4be9086c"></a><!-- doxytag: member="MazeWorld::getMinReward" ref="a8777d7082bd0512455a30a8b4be9086c" args="(const State &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::getMinReward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Based on state, get the max reward of individual mazes, sum them up. Assumption: Mazes do not interact to give more rewards. </p>

<p>Reimplemented in <a class="el" href="class_ghost_busters_level.html#ac80188f6fcc978fcde0ef6321cdb2db9">GhostBustersLevel</a>.</p>

</div>
</div>
<a class="anchor" id="a9f57ae8aec5b7d79a73dfc44e6841f99"></a><!-- doxytag: member="MazeWorld::getNumAliveWorlds" ref="a9f57ae8aec5b7d79a73dfc44e6841f99" args="(const State &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MazeWorld::getNumAliveWorlds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns number of sub-worlds that are not terminal. </p>

</div>
</div>
<a class="anchor" id="ab72b9362f9a3ab8d4933bd57b2b259a9"></a><!-- doxytag: member="MazeWorld::getPlayerString" ref="ab72b9362f9a3ab8d4933bd57b2b259a9" args="(int playerIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * MazeWorld::getPlayerString </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the string representing the player's role to be sent to client </p>

</div>
</div>
<a class="anchor" id="a9abacdc3ef9d5c26370e827510f8cb6e"></a><!-- doxytag: member="MazeWorld::getPlayerStringXML" ref="a9abacdc3ef9d5c26370e827510f8cb6e" args="(int playerIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * MazeWorld::getPlayerStringXML </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the string representing the player's role to be sent to client, in XML format. </p>

</div>
</div>
<a class="anchor" id="a5a7d847278a8d592f6afb8ef3818e4b2"></a><!-- doxytag: member="MazeWorld::getQValues" ref="a5a7d847278a8d592f6afb8ef3818e4b2" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, vector&lt; pair&lt; long, double &gt; &gt; &amp;QValues, long playerAct=&#45;1, int playerIndex=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::getQValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; long, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>QValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>playerAct</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the Q values of valid compound acts with respect to the supplied <em>playerAct</em> of <em>playerIndex</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">QValues</td><td>output Q values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04c4312f522f78bb08ddf919f5cd1299"></a><!-- doxytag: member="MazeWorld::getRandomizedGrid" ref="a04c4312f522f78bb08ddf919f5cd1299" args="(long &amp;x, long &amp;y, std::vector&lt; long &gt; &amp;occupiedGrids, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::getRandomizedGrid </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>occupiedGrids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get randomized x, y such that they represent coords of a grid that is 1. not wall 2. not in occupiedGrids </p>

</div>
</div>
<a class="anchor" id="ac58a1d772b7d862e4c541eab63cd2a9c"></a><!-- doxytag: member="MazeWorld::getRandomizedState" ref="ac58a1d772b7d862e4c541eab63cd2a9c" args="(State &amp;state, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::getRandomizedState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Similar to getCurrState but with randomization </p>

</div>
</div>
<a class="anchor" id="ada8facde539f034b72b3de4e404d620e"></a><!-- doxytag: member="MazeWorld::getReward" ref="ada8facde539f034b72b3de4e404d620e" args="(const State &amp;state, bool &amp;terminal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double MazeWorld::getReward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>terminal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Globally assesses the terminal status of <em>state</em>. This could be used in the case when human has hitpoints. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Current <a class="el" href="struct_state.html">State</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">terminal</td><td>true if terminal, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reward of <em>state</em>. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ghost_busters_level.html#a1f9b2e010a99467bf43c733f317e3ae1">GhostBustersLevel</a>.</p>

</div>
</div>
<a class="anchor" id="a4483788d58851d971a85675d0acc5392"></a><!-- doxytag: member="MazeWorld::getSubworldAliveStatus" ref="a4483788d58851d971a85675d0acc5392" args="(const State &amp;state, std::vector&lt; bool &gt; &amp;aliveStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MazeWorld::getSubworldAliveStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>aliveStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>number of alive subworlds </dd></dl>

</div>
</div>
<a class="anchor" id="ab50460352527c757108d6acf05f86558"></a><!-- doxytag: member="MazeWorld::getTopology" ref="ab50460352527c757108d6acf05f86558" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::getTopology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute geographical info.</p>
<p>Construct the connectivity of map space, regions' type, neighbor edge length, area and visible nearby regions </p>

</div>
</div>
<a class="anchor" id="acde128844c14b2e019e1b61a2f4658d7"></a><!-- doxytag: member="MazeWorld::getValidCompoundActions" ref="acde128844c14b2e019e1b61a2f4658d7" args="(const State &amp;state, vector&lt; long &gt; &amp;validActions, long playerAction=&#45;1, int playerIndex=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::getValidCompoundActions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>validActions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>playerAction</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine returns only the valid actions (those not hitting against wall, etc.)</p>
<p>This default version returns valid movement actions. Special actions are assumed to be all valid at any point of time. </p>

</div>
</div>
<a class="anchor" id="a09f6e0dfe61c250fdb7a2130ba6d9dad"></a><!-- doxytag: member="MazeWorld::getWorldRepresentation" ref="a09f6e0dfe61c250fdb7a2130ba6d9dad" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* MazeWorld::getWorldRepresentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the char array representing the world map (integers separated by space). In GhostBusters, it has the following format:<ul>
<li>xSize</li>
<li>ySize</li>
<li>Map of the form &lt;0,1&gt;; 0: ground, 1: wall; -1: sheep's pen; -2: fiery men's pen; -3: fiery men's exit</li>
<li>worldType array (1: sheep, 2: ghost, ) </li>
</ul>
</dd></dl>

<p>Implemented in <a class="el" href="class_ghost_busters_level.html#a3e896f3a6efaf3d94797551233aebd21">GhostBustersLevel</a>.</p>

</div>
</div>
<a class="anchor" id="a45f9066eaf97820d58b9a782705eac0a"></a><!-- doxytag: member="MazeWorld::getWorldRepresentationXML" ref="a45f9066eaf97820d58b9a782705eac0a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual char* MazeWorld::getWorldRepresentationXML </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the XML message representing the world map. Sample format: </p>
<div class="fragment"><pre class="fragment">
	 &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	 &lt;map width="11" height="11"&gt;
	 &lt;grid&gt;
	 &lt;tile x="" y="" type="wall"/&gt;
	 &lt;tile x="" y="" type="player1"/&gt;
	 &lt;/grid&gt;
	 &lt;world_types&gt;
	 &lt;world id="0" type="sheep"&gt;
	 &lt;world id="1" type="sheep"&gt;
	 &lt;world id="2" type="fiery"&gt;
	 &lt;world id="3" type="ghost"&gt;
	 &lt;/world_types&gt;
	 &lt;/map&gt;
	 </pre></div> 
<p>Implemented in <a class="el" href="class_ghost_busters_level.html#a76159fa5fbbf426b67b6300b12aa9ac2">GhostBustersLevel</a>.</p>

</div>
</div>
<a class="anchor" id="a31ae4adb74ed80ae629562a2addeb413"></a><!-- doxytag: member="MazeWorld::gotInteraction" ref="a31ae4adb74ed80ae629562a2addeb413" args="(const State &amp;state)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MazeWorld::gotInteraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the subworlds at current state interact. </dd></dl>

<p>Implemented in <a class="el" href="class_ghost_busters_level.html#a74899b2994e187d36b022d270f117d67">GhostBustersLevel</a>.</p>

</div>
</div>
<a class="anchor" id="aa3b206f0451bc8b7a350e4cef987086a"></a><!-- doxytag: member="MazeWorld::hasMonster" ref="aa3b206f0451bc8b7a350e4cef987086a" args="(const State &amp;state, long x, long y, string monsterName=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MazeWorld::hasMonster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>monsterName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility function to check whether there is an alive monster at x,y </p>

</div>
</div>
<a class="anchor" id="ac1af92861c0f563f65d632f8db72ef63"></a><!-- doxytag: member="MazeWorld::hasOneSubworldAlive" ref="ac1af92861c0f563f65d632f8db72ef63" args="(const State &amp;currState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MazeWorld::hasOneSubworldAlive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the subWorld id if there is exactly one subWorld alive, -1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a84a123d52de638129023d1a0418c9495"></a><!-- doxytag: member="MazeWorld::initializeHumanAssistantMazes" ref="a84a123d52de638129023d1a0418c9495" args="(MazeWorldDescription &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MazeWorld::initializeHumanAssistantMazes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_maze_world_description.html">MazeWorldDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine is to be called after the constructor.</p>
<p>Initialize the following properties:</p>
<ul>
<li>numStateVars</li>
<li>numWorlds</li>
<li>equivWorlds</li>
<li>worldType</li>
<li>numHumanActs</li>
<li>numAiActs</li>
<li>visionLimit // for now, since the abstract state depends on visionLimit, we're using only one visionLimit accross worlds. </li>
</ul>

<p>Implemented in <a class="el" href="class_ghost_busters_level.html#ae7507631bd3b25343c5f2ab38285523e">GhostBustersLevel</a>.</p>

</div>
</div>
<a class="anchor" id="a220829ac4eb9ace9c1d4e7f77e9d90a4"></a><!-- doxytag: member="MazeWorld::isBlockedAt" ref="a220829ac4eb9ace9c1d4e7f77e9d90a4" args="(const State *state, long x, long y, long &amp;monsterNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MazeWorld::isBlockedAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>monsterNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>current <a class="el" href="struct_state.html">State</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>X coord. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Y coord. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">monsterNum</td><td>the world id that has monster at location (x,y). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if state has a monster still alive at location (x, y) and false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7649a247ddf42879cea52b21ad4cfb8f"></a><!-- doxytag: member="MazeWorld::isTermState" ref="a7649a247ddf42879cea52b21ad4cfb8f" args="(const State &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MazeWorld::isTermState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="struct_state.html">State</a> is terminal if: 1. Human's X coord is TermState (this is a global terminal sign) 2. Depending on gameType, when all sub-world is terminal or just any of them is. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>whether <a class="el" href="struct_state.html">State</a> <em>state</em> is terminal </dd></dl>

<p>Implements <a class="el" href="class_model.html#af553526fe97f17621d5c3bc86273658f">Model</a>.</p>

</div>
</div>
<a class="anchor" id="a784453673bdce371b26fbf5b36455e2c"></a><!-- doxytag: member="MazeWorld::isValidMonsterMove" ref="a784453673bdce371b26fbf5b36455e2c" args="(Monster *monster, long monsterX, long monsterY, const State *currState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MazeWorld::isValidMonsterMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_monster.html">Monster</a> *&#160;</td>
          <td class="paramname"><em>monster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> *&#160;</td>
          <td class="paramname"><em>currState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check whether this monster coordinates is valid w.r.t the blocking conditions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monster</td><td>the <a class="el" href="class_monster.html" title="Base class of all NPCs.">Monster</a> in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterX</td><td>the X coordinate of the questioned position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterX</td><td>the Y coordinate of the questioned position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>current state </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the gridNodeLabel of location (<em>monsterX</em>, <em>monsterY</em>) if valid, -1 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a137d5176008d0ad413eb2d50755c764a"></a><!-- doxytag: member="MazeWorld::isValidMove" ref="a137d5176008d0ad413eb2d50755c764a" args="(long tempX, long tempY, long currAgentX, long currAgentY, const State &amp;currState, vector&lt; int &gt; *succeedArray=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MazeWorld::isValidMove </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tempX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tempY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>currAgentX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>currAgentY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>succeedArray</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check whether the location (<em>tempX</em>, <em>tempY</em>) is a valid destination for coordinates is valid w.r.t the blocking conditions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tempX</td><td>X coord in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tempY</td><td>Y coord in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currAgentX</td><td>the current X coordinate of the agent in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currAgentY</td><td>the current Y coordinate of the agent in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>current state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">succeedArray</td><td>stores value of 1 or 0 for each of the Maze's. 1 means the move is valid in that world, 0 means the move is invalid in that world. This info hints the assistant on which world is the blocking world. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if valid, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae92362afe4641c949fb7d64ba189303f"></a><!-- doxytag: member="MazeWorld::moveState" ref="ae92362afe4641c949fb7d64ba189303f" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long player0Act, long player1Act, int playerIndex, State &amp;nextState, vector&lt; long &gt; &amp;monsterActions, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::moveState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>player0Act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>player1Act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>monsterActions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Duplicate of sample routine, used for updating belief based on real human actions.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reward after executing player0Act and player1Act </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>current state </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nextState</td><td>next state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a230c33bc04c02695f4cc5ab225436e43"></a><!-- doxytag: member="MazeWorld::negativeInteract" ref="a230c33bc04c02695f4cc5ab225436e43" args="(const State &amp;state, long i, long j)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MazeWorld::negativeInteract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if world i and world j can negatively interact one another. </dd></dl>

<p>Implemented in <a class="el" href="class_ghost_busters_level.html#aa6234e7b5266c751b3aa9af79f173182">GhostBustersLevel</a>.</p>

</div>
</div>
<a class="anchor" id="a89b34a8e39e4ebf4de4d5d2c395e5b37"></a><!-- doxytag: member="MazeWorld::policy" ref="a89b34a8e39e4ebf4de4d5d2c395e5b37" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;p1act, long &amp;p2act, State &amp;nextState, vector&lt; long &gt; &amp;monsterActions, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::policy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>p1act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>p2act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>monsterActions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>policy is invoked to simulate actions, so in here, human is assumed to be player[0], assistant player[1] </p>

</div>
</div>
<a class="anchor" id="a601eca91dd91699fcdfded87fc708ab1"></a><!-- doxytag: member="MazeWorld::policyHuman_stupidAI" ref="a601eca91dd91699fcdfded87fc708ab1" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long playerAct, int playerIndex, long &amp;aiAct, State &amp;nextState, vector&lt; long &gt; &amp;monsterActions, RandSource &amp;randSource, int scriptMode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::policyHuman_stupidAI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>playerAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>aiAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>monsterActions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scriptMode</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scriptMode</td><td>0:do nothing, 1:random, 2:follows human, 3:closestToHuman </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8d64ab17756316122f4736b3d1ca664"></a><!-- doxytag: member="MazeWorld::policyRoutine" ref="ac8d64ab17756316122f4736b3d1ca664" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;bestAiAct, long playerAct, int playerIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MazeWorld::policyRoutine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>bestAiAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>playerAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given Human's action, obtains best AiAssistant's action. Invoked by <em>policy</em> and <em>policyHuman</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>Current <a class="el" href="struct_state.html">State</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bestAiAct</td><td>the ai action to be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playerAct</td><td>Index of Human action to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">randSource</td><td>Source of random numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if currState is not terminal, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b39300aececdf9c510d16ad1ea90de0"></a><!-- doxytag: member="MazeWorld::printGrid" ref="a5b39300aececdf9c510d16ad1ea90de0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::printGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility function to print the grid array. </p>

</div>
</div>
<a class="anchor" id="a234218d45222dea42165110a4e1c72dd"></a><!-- doxytag: member="MazeWorld::readDescriptionFromTMXFile" ref="a234218d45222dea42165110a4e1c72dd" args="(string filename, GameTileSheet &amp;gts, MazeWorldDescription &amp;desc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::readDescriptionFromTMXFile </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_game_tile_sheet.html">GameTileSheet</a> &amp;&#160;</td>
          <td class="paramname"><em>gts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_maze_world_description.html">MazeWorldDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads in problem parameters from TMX file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the TMX file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gts</td><td><a class="el" href="class_game_tile_sheet.html" title="Contains information about the game tile sheet.">GameTileSheet</a> object that provides game's tile ids. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">desc</td><td>resulted description object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf45b03e2c29c45285ca601e56a0823a"></a><!-- doxytag: member="MazeWorld::readSolution" ref="aaf45b03e2c29c45285ca601e56a0823a" args="(string filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::readSolution </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read in the QFns from file <em>filename</em> and reconstruct collabQFn of all mazes. </p>

<p><p>Note that equivWorlds is not in the memory, we reconstruct it on the fly</p>
</p>

</div>
</div>
<a class="anchor" id="a328c7d35892221fc7bc41fced09ef78c"></a><!-- doxytag: member="MazeWorld::realDynamics" ref="a328c7d35892221fc7bc41fced09ef78c" args="(const State &amp;currState, long player0Act, long player1Act, State &amp;nextState, vector&lt; int &gt; &amp;succeedArray, vector&lt; int &gt; &amp;terminalArray, vector&lt; long &gt; &amp;monsterActions, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::realDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>player0Act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>player1Act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>succeedArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>terminalArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>monsterActions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>NOTE: terminalArray is not updated, why??? Cause it's not needed?</p>
<p>Dynamics of the real world. Given current state of the world, players' action, returns a sample of the next state and its reward. realDynamics is always called when currState is not terminal, so there's no need to check for terminus.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reward of doing <em>act</em> in <em>currState</em>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>Current state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">player0Act</td><td>Index of human action to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">player1Act</td><td>Index of AI action to perform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nextState</td><td>Sampled next state. This is random and changes from invocation to invocation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">succeedArray</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">terminalArray</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">randSource</td><td>Source of random numbers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e8c361ad7dc7ab591cb0dc606849319"></a><!-- doxytag: member="MazeWorld::realToVirtual" ref="a6e8c361ad7dc7ab591cb0dc606849319" args="(const State &amp;currState, const long worldNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long MazeWorld::realToVirtual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>worldNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used for mapping real world state to virtual world states </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Given the state <em>currState</em> of the real world, return the state of the virtual world with number <em>worldNum</em>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>Current state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">worldNum</td><td>Which virtual world </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ff2440f157082285088a02a5323bc8a"></a><!-- doxytag: member="MazeWorld::rewardFromRealDynamics" ref="a9ff2440f157082285088a02a5323bc8a" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long player0Act, long player1Act, int playerIndex, State &amp;nextState, vector&lt; vector&lt; double &gt; &gt; &amp;condProbAct, vector&lt; long &gt; &amp;monsterActions, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::rewardFromRealDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>player0Act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>player1Act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>playerIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>condProbAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>monsterActions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invokes realDynamics to return the reward.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reward of doing <em>act</em> in <em>currState</em>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>Current <a class="el" href="struct_state.html">State</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">player0Act</td><td>Index of human action to perform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">player1Act</td><td>Index of AI action to perform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nextState</td><td>Sampled next state. This is random and changes from invocation to invocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condProbAct</td><td>this human's action model is obtained to update the assistant's world belief. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">randSource</td><td>Source of random numbers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af208f1a60114068b493fd7472d5a3328"></a><!-- doxytag: member="MazeWorld::sample" ref="af208f1a60114068b493fd7472d5a3328" args="(const State &amp;currState, vector&lt; double &gt; &amp;wBelief, long &amp;humanAct, long &amp;aiAct, State &amp;nextState, vector&lt; long &gt; &amp;monsterActions, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MazeWorld::sample </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>wBelief</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>humanAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>aiAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>monsterActions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sample the other action given one action. wBelief is updated in the process. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>Current state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wBelief</td><td>world's belief. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiAct</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">humanAct</td><td>the sampled human action. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nextState</td><td>Sampled next state. This is random and changes from invocation to invocation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">randSource</td><td>Source of random numbers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8a1bca5cb6e468450d00c7d8099dcc5"></a><!-- doxytag: member="MazeWorld::setDefaultVisionLimit" ref="ad8a1bca5cb6e468450d00c7d8099dcc5" args="(double visLim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MazeWorld::setDefaultVisionLimit </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>visLim</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the vision limit to use for abstract state generation. </p>

</div>
</div>
<a class="anchor" id="af5460232c8e15a87ecc70e0b6c33c9df"></a><!-- doxytag: member="MazeWorld::setUseAbstract" ref="af5460232c8e15a87ecc70e0b6c33c9df" args="(bool uA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::setUseAbstract </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uA</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the problem to be solved using abstract state or not. </p>

</div>
</div>
<a class="anchor" id="acbb72a615c2e69496db99d3b6129102b"></a><!-- doxytag: member="MazeWorld::stateToPosChar" ref="acbb72a615c2e69496db99d3b6129102b" args="(const AugmentedState &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * MazeWorld::stateToPosChar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_augmented_state.html">AugmentedState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts <em>state</em> to char array. </p>

<p>Implements <a class="el" href="class_model.html#a16ef88ad6490f1210528289f5dd44396">Model</a>.</p>

</div>
</div>
<a class="anchor" id="a64c50a5c4fe02ecca4aa0b66863c7cfc"></a><!-- doxytag: member="MazeWorld::stateToPosCharXML" ref="a64c50a5c4fe02ecca4aa0b66863c7cfc" args="(const AugmentedState &amp;state, const int timeStamp=&#45;2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * MazeWorld::stateToPosCharXML </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_augmented_state.html">AugmentedState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>timeStamp</em> = <code>-2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts <em>state</em> to XML msg with timeStamp. </p>

<p>Implements <a class="el" href="class_model.html">Model</a>.</p>

</div>
</div>
<a class="anchor" id="afb7de284612b7d0ecc28601a5182b9ef"></a><!-- doxytag: member="MazeWorld::worldInitialize" ref="afb7de284612b7d0ecc28601a5182b9ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::worldInitialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize and compute geographical info. </p>

</div>
</div>
<a class="anchor" id="a71095018856a59ebbe07529603d824d2"></a><!-- doxytag: member="MazeWorld::writeSolution" ref="a71095018856a59ebbe07529603d824d2" args="(string filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MazeWorld::writeSolution </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write out the QFns to <em>filename</em>. Exploit <em>equivWorlds</em> - only write a pointer to earlier model when model is equivalent. </p>

<p><p>Only write a pointer to earlier model when model is equivalent. Format: 10 //numWorlds 0 // index, if equal to the index, it is original 5 // virtualSizes[0]: number of states in virtual world 0 1.2 2.3 3.4 4.5 5.6 // virtualValueFns[0] 1.2 2.3 3.4 4.5 5.6 // vHumanIndeptVFns[0] 1.2 2.3 3.4 4.5 5.6 // vAiIndeptVFns[0] 0 // index, not equal to the actual index, therefore a duplicate/replica</p>
<p>New: Write filename.worldTypeStr.Ftn for each of the world type. Format: virtualSize Q value</p>
</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad4d3258814fe3a748105837917b4f6ab"></a><!-- doxytag: member="MazeWorld::agentBlock" ref="ad4d3258814fe3a748105837917b4f6ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_maze_world.html#ad4d3258814fe3a748105837917b4f6ab">MazeWorld::agentBlock</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blocking flag for agents. True of agents block each other, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a78a71b1f3e46d87fe3deebe7e505a460"></a><!-- doxytag: member="MazeWorld::borderLength" ref="a78a71b1f3e46d87fe3deebe7e505a460" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;long&gt; &gt; <a class="el" href="class_maze_world.html#a78a71b1f3e46d87fe3deebe7e505a460">MazeWorld::borderLength</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The lengths of common edges between neighbor regions, indexed by region id and neighbor region id. borderLength[i][unchanged] is the area of that region, borderLength[i][east/west/south/norht] is either 1 (next to a region) or 0 (next to wall) </p>

</div>
</div>
<a class="anchor" id="a47c07595f07a1347f5e11a8c543bd613"></a><!-- doxytag: member="MazeWorld::connectivity" ref="a47c07595f07a1347f5e11a8c543bd613" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;long&gt; &gt; <a class="el" href="class_maze_world.html#a47c07595f07a1347f5e11a8c543bd613">MazeWorld::connectivity</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Array indexed by region index containing neighbor regions on the east, south, west and north sides. </p>

</div>
</div>
<a class="anchor" id="a5c16ab97f494d794c929863c7168a7c0"></a><!-- doxytag: member="MazeWorld::displayInterval" ref="a5c16ab97f494d794c929863c7168a7c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_maze_world.html#a5c16ab97f494d794c929863c7168a7c0">MazeWorld::displayInterval</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Time interval to display the value's difference. </p>

</div>
</div>
<a class="anchor" id="a3959bfff171aec5dc1b988338ff689c8"></a><!-- doxytag: member="MazeWorld::equivWorlds" ref="a3959bfff171aec5dc1b988338ff689c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;long&gt; <a class="el" href="class_maze_world.html#a3959bfff171aec5dc1b988338ff689c8">MazeWorld::equivWorlds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The vector of original worlds' indices, i.e. earliests model that is equiv to this one. </p>

</div>
</div>
<a class="anchor" id="a971cb8af34ba380d3d0be5b1ee3a9e6d"></a><!-- doxytag: member="MazeWorld::grid" ref="a971cb8af34ba380d3d0be5b1ee3a9e6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;long&gt; &gt; <a class="el" href="class_maze_world.html#a971cb8af34ba380d3d0be5b1ee3a9e6d">MazeWorld::grid</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Raster scanned grid. </p>

</div>
</div>
<a class="anchor" id="a02167c7ca4d0cd5984feed998f0fbb6c"></a><!-- doxytag: member="MazeWorld::gridNodeLabel" ref="a02167c7ca4d0cd5984feed998f0fbb6c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;long&gt; &gt; <a class="el" href="class_maze_world.html#a02167c7ca4d0cd5984feed998f0fbb6c">MazeWorld::gridNodeLabel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Integer label of accessible grid squares. </p>

</div>
</div>
<a class="anchor" id="a8aeb5c1eae4d74443383a0eece6269b6"></a><!-- doxytag: member="MazeWorld::gType" ref="a8aeb5c1eae4d74443383a0eece6269b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utilities.html#a30ae08a60e405d53094bec28df74ba7a">Utilities::goalType</a> <a class="el" href="class_maze_world.html#a8aeb5c1eae4d74443383a0eece6269b6">MazeWorld::gType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type of the game goal. It could take value of Utilities::orType, i.e. the game ends when one of the worlds (Mazes) ends, or Utilities::andType, i.e. the game ends only when all of the worlds end. </p>

</div>
</div>
<a class="anchor" id="abdb160e5fc085a5e6d84e59834c541ac"></a><!-- doxytag: member="MazeWorld::lastState" ref="abdb160e5fc085a5e6d84e59834c541ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_augmented_state.html">AugmentedState</a> <a class="el" href="class_maze_world.html#abdb160e5fc085a5e6d84e59834c541ac">MazeWorld::lastState</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Originally, the last state is updated by the <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>, which overrides human's coordinates with TermState. In order to facilitate display for client, the state before being overriden is stored here. </p>

</div>
</div>
<a class="anchor" id="ad5e853b690e4594b55b3b83dda6c1151"></a><!-- doxytag: member="MazeWorld::mazes" ref="ad5e853b690e4594b55b3b83dda6c1151" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_maze.html">Maze</a>*&gt; <a class="el" href="class_maze_world.html#ad5e853b690e4594b55b3b83dda6c1151">MazeWorld::mazes</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Vector of pointers to individual Mazes. </p>

</div>
</div>
<a class="anchor" id="a94bbfb19123761d2ad660d626e83132f"></a><!-- doxytag: member="MazeWorld::numAccessibleLocs" ref="a94bbfb19123761d2ad660d626e83132f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_maze_world.html#a94bbfb19123761d2ad660d626e83132f">MazeWorld::numAccessibleLocs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of accessible grid squares in the grid. </p>

</div>
</div>
<a class="anchor" id="a56ae73470aac1d75379ad18428877add"></a><!-- doxytag: member="MazeWorld::numRegionPerAgent" ref="a56ae73470aac1d75379ad18428877add" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_maze_world.html#a56ae73470aac1d75379ad18428877add">MazeWorld::numRegionPerAgent</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of regions in the map. </p>

</div>
</div>
<a class="anchor" id="a35bf9df51329fac0286dc94de8f4c603"></a><!-- doxytag: member="MazeWorld::numWorlds" ref="a35bf9df51329fac0286dc94de8f4c603" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_maze_world.html#a35bf9df51329fac0286dc94de8f4c603">MazeWorld::numWorlds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of individual Mazes. </p>

</div>
</div>
<a class="anchor" id="a3d9fe13eed4cdb76351c42b59718368e"></a><!-- doxytag: member="MazeWorld::player" ref="a3d9fe13eed4cdb76351c42b59718368e" args="[2]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_player.html">Player</a>* <a class="el" href="class_maze_world.html#a3d9fe13eed4cdb76351c42b59718368e">MazeWorld::player</a>[2]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the <a class="el" href="class_player.html" title="Base class of individual game&#39;s Human and AiAssistant.">Player</a> objects. </p>

</div>
</div>
<a class="anchor" id="aa21b75766ff6d1defa5a388584082ead"></a><!-- doxytag: member="MazeWorld::regionRepPoint" ref="aa21b75766ff6d1defa5a388584082ead" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;long, long&gt; &gt; <a class="el" href="class_maze_world.html#aa21b75766ff6d1defa5a388584082ead">MazeWorld::regionRepPoint</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Representative points of regions, being the westernmost/southernmost coords. Indexed by region. </p>

</div>
</div>
<a class="anchor" id="a298453db5e208f50311a4444df12e665"></a><!-- doxytag: member="MazeWorld::rType" ref="a298453db5e208f50311a4444df12e665" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;regionType&gt; <a class="el" href="class_maze_world.html#a298453db5e208f50311a4444df12e665">MazeWorld::rType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Region type. Could be vertical, horizon or junction. </p>

</div>
</div>
<a class="anchor" id="ae375e48cfcf71826f10dcb6259f9f651"></a><!-- doxytag: member="MazeWorld::targetPrecision" ref="ae375e48cfcf71826f10dcb6259f9f651" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_maze_world.html#ae375e48cfcf71826f10dcb6259f9f651">MazeWorld::targetPrecision</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Value Iteration's epsilon value, below which VI terminates. </p>

</div>
</div>
<a class="anchor" id="a36a83f5fbb99b45153a0332b69a1487b"></a><!-- doxytag: member="MazeWorld::visionLimit" ref="a36a83f5fbb99b45153a0332b69a1487b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_maze_world.html#a36a83f5fbb99b45153a0332b69a1487b">MazeWorld::visionLimit</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The default vision limit of all monsters. </p>

</div>
</div>
<a class="anchor" id="a77ff69eb37ab72e44da066149d8082d1"></a><!-- doxytag: member="MazeWorld::xSize" ref="a77ff69eb37ab72e44da066149d8082d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_maze_world.html#a77ff69eb37ab72e44da066149d8082d1">MazeWorld::xSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Grid's size. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>WorldModels/<a class="el" href="_maze_world_8h_source.html">MazeWorld.h</a></li>
<li>WorldModels/MazeWorld.cc</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_maze_world.html">MazeWorld</a>      </li>
      <li class="footer">Generated on Fri Jun 8 2012 01:14:51 for CAPIRSolver by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
