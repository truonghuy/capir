<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CAPIRSolver: Maze Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sheep-icon-normal.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CAPIRSolver&#160;<span id="projectnumber">1.0</span></div>
   <div id="projectbrief">API documentation of CAPIRSolver</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_maze.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>Maze Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Maze" -->
<p>This class is the base class for all individual tasks/puzzles that the protagonists need to solve in the whole map.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_maze_8h_source.html">Maze.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Maze:</div>
<div class="dyncontent">
<div class="center"><img src="class_maze__inherit__graph.png" border="0" usemap="#_maze_inherit__map" alt="Inheritance graph"/></div>
<map name="_maze_inherit__map" id="_maze_inherit__map">
<area shape="rect" id="node3" href="class_g_b___fiery_maze.html" title="GB_FieryMaze" alt="" coords="5,83,120,111"/><area shape="rect" id="node5" href="class_g_b___ghost_maze.html" title="GB_GhostMaze" alt="" coords="144,83,264,111"/><area shape="rect" id="node7" href="class_g_b___sheep_maze.html" title="GB_SheepMaze" alt="" coords="288,83,411,111"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Maze:</div>
<div class="dyncontent">
<div class="center"><img src="class_maze__coll__graph.png" border="0" usemap="#_maze_coll__map" alt="Collaboration graph"/></div>
<map name="_maze_coll__map" id="_maze_coll__map">
<area shape="rect" id="node19" href="class_monster.html" title="Base class of all NPCs." alt="" coords="40,473,109,501"/><area shape="rect" id="node2" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t..." alt="" coords="133,286,227,314"/><area shape="rect" id="node12" href="class_player.html" title="Base class of individual game&#39;s Human and AiAssistant." alt="" coords="80,193,141,221"/><area shape="rect" id="node4" href="class_model.html" title="Base class for MDP models." alt="" coords="220,193,279,221"/><area shape="rect" id="node6" href="struct_augmented_state.html" title="AugmentedState" alt="" coords="381,193,504,221"/><area shape="rect" id="node8" href="struct_state.html" title="State" alt="" coords="416,86,469,114"/><area shape="rect" id="node10" href="class_stats.html" title="Stats\&lt; State \&gt;" alt="" coords="388,6,497,34"/><area shape="rect" id="node14" href="class_agent.html" title="Base class of Monster and HumanAssistant." alt="" coords="83,86,139,114"/><area shape="rect" id="node16" href="class_object_with_properties.html" title="This class defines objects with properties and able to react." alt="" coords="159,6,308,34"/><area shape="rect" id="node24" href="class_special_location.html" title="SpecialLocation" alt="" coords="251,139,368,167"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_maze-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a75244a3fdce4c8b8f2fe7fa33722247e">Maze</a> (long wType, <a class="el" href="class_maze_world.html">MazeWorld</a> *<a class="el" href="class_maze.html#a358e7b04077b94e6a32e346e285a3ce8">mazeWorld</a>, <a class="el" href="class_monster.html">Monster</a> *<a class="el" href="class_maze.html#ab612d9b5fe88c95d25cde4cd01cfb5b5">monster</a>=0, <a class="el" href="class_special_location.html">SpecialLocation</a> *sLoc=0, <a class="el" href="class_player.html">Player</a> *h=0, <a class="el" href="class_player.html">Player</a> *a=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a7ecf1da4b9685f97bf3110a8479e724b">Maze</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a012aa15e27d9fd08385b95276eee6f8d">copyInfoFrom</a> (<a class="el" href="class_maze.html">Maze</a> *orig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a594b318e6608e5c207501fccf9229a27">copyStateMap</a> (<a class="el" href="class_maze.html">Maze</a> *orig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a299ec6938f6a365494ded81ba0ec8c27">copyValueQFns</a> (<a class="el" href="class_maze.html">Maze</a> *orig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a91c5ba1ff1e4da448a91c91d3cbf64b6">setProperty</a> (string pName, string pValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a27ea32d74669448a505d958bea501b4f">setHuman</a> (<a class="el" href="class_player.html">Player</a> *h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ab120d8936edd497ab60cb4cab9f5ae9f">setAssistant</a> (<a class="el" href="class_player.html">Player</a> *a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a4f3fff84acdcbe1059388b5c3d58a9cf">setPlayers</a> (<a class="el" href="class_player.html">Player</a> *h, <a class="el" href="class_player.html">Player</a> *a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#aea18278fd9f757cde5af37088c5008bb">setUseAbstract</a> (bool uA)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a72e26103733a454600dccb1f69538136">hasMonster</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#abeea7864b896d38ce3be729ca4ab69dc">getMaxReward</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#adbdd38dc460f86fb2faa99729609271b">getMinReward</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a6a831f391122630ed45c28ae3926cffc">generateStateMap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ad01dcc9c8b75f3b3cb279b6e290e6984">generateAbstractStateMap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a663ec0453a3d58c28a46a67dda427ec1">generateRawStateMap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ad93ee481e3535e8cccaa979c691ad6a7">enumerateLocationOneAgent</a> (std::vector&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a> &gt; &amp;input, std::vector&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a> &gt; &amp;output, long agentIndex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a490975a4d6559bffc844522c04b662cb">constructVisibleNearbyRegion</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ae7f88693da4f8a4b926a755f697d01e4">getAbstractWorldGeometricInfo</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a621e75ca6a010fc584d86b33c3847d76">getRawWorldGeometricInfo</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a6f1bd9b86709c45ebfa40cc7c707b595">generateModel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a23923e22f02f606083faa3bf174cd9a8">constructTRCompAct</a> (vector&lt; vector&lt; vector&lt; pair&lt; long, double &gt; &gt; &gt; &gt; &amp;transitionMatrix, vector&lt; vector&lt; double &gt; &gt; &amp;rewardMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#aecf1d96665fc5f90c813081422e3a9d3">constructCollabQFns</a> (vector&lt; vector&lt; vector&lt; pair&lt; long, double &gt; &gt; &gt; &gt; &amp;transitionMatrix, vector&lt; vector&lt; double &gt; &gt; &amp;rewardMatrix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a68efdbda53b9f30170972cbbaf938f6f">absVirtualDynamics</a> (const long currAbsState, const long hAct, const long aAct, sparseStateBelief &amp;tranProb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a00b218f33aa3cc740e7e2493ad86df57">isAbstractTerminal</a> (const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;absState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a8513ff87aac2b6a27af95aa39efcc2a3">isTermState</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, long worldNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a6e2493acfaf338f6af8df6f51475bf35">isLocalTermState</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, long worldNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdaea949cd88759ccac5dc7af2a2ff2a"></a><!-- doxytag: member="Maze::suicide" ref="abdaea949cd88759ccac5dc7af2a2ff2a" args="(State &amp;state, long worldNum)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>suicide</b> (<a class="el" href="struct_state.html">State</a> &amp;state, long worldNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a1c9ec37eba4c9f201629bed444fb4877">absExecuteAgentMoveAct</a> (std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;input, long &amp;action, int agentIndex, std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a611f53b9ef9640bfc1f5391fb691fa1c">absExecuteAgentMoveAct_gotMonster</a> (std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;input, long &amp;action, int agentIndex, std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a841a96ecf08e2b91a15155aa5f81b7de"></a><!-- doxytag: member="Maze::executeAgentMoveAct_gotMonster" ref="a841a96ecf08e2b91a15155aa5f81b7de" args="(std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;input, long &amp;action, int agentIndex, std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;output)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>executeAgentMoveAct_gotMonster</b> (std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;input, long &amp;action, int agentIndex, std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#afd26c972c65fa4e1ad2f1cbc8dee19ba">absExecuteAgentMoveAct_noMonster</a> (std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;input, long &amp;action, int agentIndex, std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a0344350384a52fa898844cbe337cdfe8">absExecuteMonsterMoveAct</a> (<a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;currAbsState, double prob, long humanAct, long aiAct, long act, double probAct, std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;output, const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;prevAbsState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#afd18251f0b1c326d9de42cafa4d818c0">absExecuteMazeDynamics</a> (std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;input, long humanAct, long aiAct, std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;output, const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;prevAbsState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ab0c42a471ba5b8082a0d30e491ec74ab">absGetReward</a> (<a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a76026f6b284f199cd7a88c5f9011da2c">absGetRewards</a> (std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;states, std::vector&lt; double &gt; &amp;rewards)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#aaba3872810abc714f32b59c7ae997eaa">getLongFromAbsState</a> (<a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;absState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a0034a3c99a5c1786038e91db358f61ef">updateVisibility</a> (<a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;absState, std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;output, long humanAct, long aiAct, long monsterAct, long priorMonsterX, long priorMonsterY, const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;prevAbsState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a00bd84c680addfec42ce730db3ae336e">updateVisibility_NoAbs</a> (<a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;absState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a8683206f101059ba94b0fc4d938b6593">playerPassable</a> (int agentIndex, long regionIndex, int monsterX=-1, int monsterY=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4124b680c6350c24683dbca8e8cca7f1"></a><!-- doxytag: member="Maze::playerPassable" ref="a4124b680c6350c24683dbca8e8cca7f1" args="(int agentIndex, long x, long y)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>playerPassable</b> (int agentIndex, long x, long y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f1a26185e3db82478059653d1468061"></a><!-- doxytag: member="Maze::monsterPassable" ref="a8f1a26185e3db82478059653d1468061" args="(long mx, long my, long p1x, long p1y, long p2x, long p2y)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>monsterPassable</b> (long mx, long my, long p1x, long p1y, long p2x, long p2y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#aac1040df91de649d968d38d4e0f91008">agentMoveCanBeBlocked</a> (const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;currAbsState, int agentIndex, long nextRegion, bool movingTowardsMonster)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a86a66c879b97c18d459e39c7b56e974c">updateCoords</a> (<a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;nextAbsState, int movingAgent, long action, long monsterRegion)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a67f7131e08c547ee5223d16f9bc42178">updateCoordsByMonsterMove</a> (<a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;absState, long monsterAct, long priorMonsterRegion)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ab53296e217e438d104b28bccbf6fab2b">standardizeCoords</a> (<a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;absState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#abf30f7c50f0083e729181f2bb0789335">updateVisibilityCoordsOneAgent</a> (std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;input, std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;output, long monsterAct, long priorMonsterX, long priorMonsterY, long agentAct, int agentIndex, const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;prevAbsState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a040e8febbd660395ab8c7b0cda402c17">getLongAbsStateFromState</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, long worldNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa72d790eb3ddcc1abb3ad5512ab5b798"></a><!-- doxytag: member="Maze::getLongAbsStateFromState_NoAbs" ref="aa72d790eb3ddcc1abb3ad5512ab5b798" args="(const State &amp;state, long worldNum)" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>getLongAbsStateFromState_NoAbs</b> (const <a class="el" href="struct_state.html">State</a> &amp;state, long worldNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a1970ceac5e6241498202e3c5f1c638e5">executeMazeDynamics</a> (<a class="el" href="struct_state.html">State</a> &amp;nextState, int worldNum, <a class="el" href="class_rand_source.html">RandSource</a> &amp;randSource)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a52827542e60ade8c2ef721c6365c864c">getCurrState</a> (vector&lt; long &gt; &amp;propertiesState, long newX=-1, long newY=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#aaaa9a56eb59f44119996b871d366bcd7">getReward</a> (const <a class="el" href="struct_state.html">State</a> &amp;state, bool &amp;vTerminal, int worldNum)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a9da719edbff6ad0914577ce7f3cfdd25">realToVirtual</a> (const <a class="el" href="struct_state.html">State</a> &amp;currState, const long worldNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ac51732446025fe4e5f483a9141a7bee6">distance_farthestFromBoth</a> (long monsterNode, long nearestAgentNode, unsigned nearestAgentIndex, long fartherAgentNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a42a5f75698b89caeabee6c6765ddb71b">distance_farthestFromPlayer</a> (long monsterNode, long agentNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a229ae798c8faa1b4cb1cabd7a1db8e43">distance_towardsNode</a> (long monsterNode, long destNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a538506a9125120ac5b220b96b5db0939">isValidMove</a> (int agentIndex, long tempX, long tempY, long otherAgentX, long otherAgentY, const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;currState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a34075ab43d867af376a9c03101909e97">regionVisible</a> (long monsterGridNode, long region)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a1850c647d8c03fdf06a0bfc9d32f2466">checkVisibility</a> (long p1X, long p1Y, long p2X, long p2Y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a4c80a0e66de89f9638e16f6f83c115e9">towardsTheOther</a> (long p1X, long p1Y, long action, long p2X, long p2Y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ab23fb7d220e07119cd763735123823a1">deleteCommonPointers</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a7dd5ff791f5b45cff2a0498763398965">worldType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a827027dd364807efd8e9875115609ddf">worldTypeStr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_maze_world.html">MazeWorld</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a358e7b04077b94e6a32e346e285a3ce8">mazeWorld</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_monster.html">Monster</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ab612d9b5fe88c95d25cde4cd01cfb5b5">monster</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_special_location.html">SpecialLocation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#acf2dd7249500505fc6f4a05bd0cd53af">specialLocation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_player.html">Player</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#aa89eedef611d421e299676e8dfa7a589">player</a> [2]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a3d78602c03c0d90619fa743c93f1bd96">virtualSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a465cff1bcf4083a4a1c4ea782066d4a6">useAbstract</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a7cb48752d0b97561eb7eba4c01cd6f54">visionLimit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a8a46a749b5d1f268e5fb9f7f198d5c8b">valueFn</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a80372d46277e64e72157e2bc0c59bc36">collabQFn</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; long &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a43258bc77fe635c3dea20ab04900fb2b">grid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; long &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a00d2c4057ffa2132623c0badd91312a1">gridNodeLabel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; long &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#ae9415e8201667a551ed7d1aa21ad9dce">connectivity</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; long &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#aabbd7a095b01ffbaf0aaa28b4bc2db8c">borderLength</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; long, long &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a0ae65512cb2e896861d1e38de432b30b">regionRepPoint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; regionType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a69c4f5c810cd2ab5a60ce13b919b1c47">rType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a1c544bba62b98fb6ae13817d1fc3fa50">numAccessibleLocs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; std::pair&lt; long, long &gt; &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a891498967d3d7be11aeff899854c1fea">visibleNearByRegions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, long, <br class="typebreak"/>
<a class="el" href="class_utilities_1_1_abstract_state_comparator.html">Utilities::AbstractStateComparator</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a47e9bef9633745c37f9565ee002f8bbd">vAbsStateMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_maze.html#a768366ad0e8deb6fd4c7008be57bd0f5">reverseVAbsStateMap</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class is the base class for all individual tasks/puzzles that the protagonists need to solve in the whole map. </p>
<p>This class holds</p>
<ul>
<li>One or no <a class="el" href="class_monster.html" title="Base class of all NPCs.">Monster</a>.</li>
<li>References to the agents and geometrical data, used for planning.</li>
<li>All planning is done in child classes of this class.</li>
</ul>
<p>This class takes care of the following:</p>
<ul>
<li>Deallocate <a class="el" href="class_monster.html" title="Base class of all NPCs.">Monster</a> object.</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Truong Huy Nguyen </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>December 2010 </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a75244a3fdce4c8b8f2fe7fa33722247e"></a><!-- doxytag: member="Maze::Maze" ref="a75244a3fdce4c8b8f2fe7fa33722247e" args="(long wType, MazeWorld *mazeWorld, Monster *monster=0, SpecialLocation *sLoc=0, Player *h=0, Player *a=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Maze::Maze </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>wType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_maze_world.html">MazeWorld</a> *&#160;</td>
          <td class="paramname"><em>mazeWorld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_monster.html">Monster</a> *&#160;</td>
          <td class="paramname"><em>monster</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_special_location.html">SpecialLocation</a> *&#160;</td>
          <td class="paramname"><em>sLoc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_player.html">Player</a> *&#160;</td>
          <td class="paramname"><em>h</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_player.html">Player</a> *&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Full constructor. </p>

</div>
</div>
<a class="anchor" id="a7ecf1da4b9685f97bf3110a8479e724b"></a><!-- doxytag: member="Maze::Maze" ref="a7ecf1da4b9685f97bf3110a8479e724b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Maze::Maze </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. Not supposed to be used. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1c9ec37eba4c9f201629bed444fb4877"></a><!-- doxytag: member="Maze::absExecuteAgentMoveAct" ref="a1c9ec37eba4c9f201629bed444fb4877" args="(std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;input, long &amp;action, int agentIndex, std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::absExecuteAgentMoveAct </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes movement action of <em>agentIndex</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>the vector of prior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>movement action of <em>agentIndex</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agentIndex</td><td>0 is Human, 1 is Assistant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the vector of posterior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a611f53b9ef9640bfc1f5391fb691fa1c"></a><!-- doxytag: member="Maze::absExecuteAgentMoveAct_gotMonster" ref="a611f53b9ef9640bfc1f5391fb691fa1c" args="(std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;input, long &amp;action, int agentIndex, std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::absExecuteAgentMoveAct_gotMonster </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes movement action of <em>agentIndex</em>, invoked by absExecuteAgentMoveAct when this <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> has monster. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>the vector of prior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>movement action of <em>agentIndex</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agentIndex</td><td>0 is Human, 1 is Assistant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the vector of posterior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine is called before monster making its move, so all abs states can't be terminal yet agentIndex == humanIndex -&gt; human </p>

</div>
</div>
<a class="anchor" id="afd26c972c65fa4e1ad2f1cbc8dee19ba"></a><!-- doxytag: member="Maze::absExecuteAgentMoveAct_noMonster" ref="afd26c972c65fa4e1ad2f1cbc8dee19ba" args="(std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;input, long &amp;action, int agentIndex, std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Maze::absExecuteAgentMoveAct_noMonster </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>NOT implemented. Executes movement action of <em>agentIndex</em>, invoked by absExecuteAgentMoveAct when this <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> does not have monster. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>the vector of prior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>movement action of <em>agentIndex</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agentIndex</td><td>0 is Human, 1 is Assistant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the vector of posterior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd18251f0b1c326d9de42cafa4d818c0"></a><!-- doxytag: member="Maze::absExecuteMazeDynamics" ref="afd18251f0b1c326d9de42cafa4d818c0" args="(std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;input, long humanAct, long aiAct, std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;output, const AbstractState &amp;prevAbsState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::absExecuteMazeDynamics </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>humanAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>aiAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>prevAbsState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> dynamics. This invokes monster and specialLocation's reactions. This routine should take care of the dynamics of shared items as well. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>the vector of prior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">humanAct</td><td>action of Human. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiAct</td><td>action of Assistant. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the vector of posterior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevAbsState</td><td>the <a class="el" href="struct_abstract_state.html">AbstractState</a> prior to applying <em>humanAct</em> and <em>aiAct</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0344350384a52fa898844cbe337cdfe8"></a><!-- doxytag: member="Maze::absExecuteMonsterMoveAct" ref="a0344350384a52fa898844cbe337cdfe8" args="(AbstractState &amp;currAbsState, double prob, long humanAct, long aiAct, long act, double probAct, std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;output, const AbstractState &amp;prevAbsState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::absExecuteMonsterMoveAct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>currAbsState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>humanAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>aiAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>probAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>prevAbsState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Executes movement action of monster. Note that this routine is invoked after Human and Assistant's actions have been applied on <a class="el" href="struct_abstract_state.html">AbstractState</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currAbsState</td><td>the current <a class="el" href="struct_abstract_state.html">AbstractState</a> to be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prob</td><td>probability of <em>currAbsState</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">humanAct</td><td>previous action of Human. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiAct</td><td>previous action of Assistant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">act</td><td>movement action of monster. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probAct</td><td>probability of this movement action of monster. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the vector of posterior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevAbsState</td><td>the <a class="el" href="struct_abstract_state.html">AbstractState</a> prior to applying <em>humanAct</em> and <em>aiAct</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0c42a471ba5b8082a0d30e491ec74ab"></a><!-- doxytag: member="Maze::absGetReward" ref="ab0c42a471ba5b8082a0d30e491ec74ab" args="(AbstractState &amp;state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Maze::absGetReward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>New! I turned the input <em>state</em> to constant, therefore, there's no way to change the value of state in here. Whatever update must be done in <a class="el" href="class_monster.html#a91c70918d2b4e214c623f52fd9a02314">Monster::absReact</a> or <a class="el" href="class_object_with_properties.html#a9c8084d441c3868dbcb8bd3d6230715b">SpecialLocation::absReact</a>. Each individual <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> must implement this routine, which returns a reward for the current abstract state. </p>

<p>Reimplemented in <a class="el" href="class_g_b___fiery_maze.html#add4db641ce1a04852460344476c80d3d">GB_FieryMaze</a>, <a class="el" href="class_g_b___ghost_maze.html#ae042d602e1a6b0b7278a4fbee0ea4749">GB_GhostMaze</a>, and <a class="el" href="class_g_b___sheep_maze.html#a9c9e69123ef4e5d4f861fcc6d2981c11">GB_SheepMaze</a>.</p>

</div>
</div>
<a class="anchor" id="a76026f6b284f199cd7a88c5f9011da2c"></a><!-- doxytag: member="Maze::absGetRewards" ref="a76026f6b284f199cd7a88c5f9011da2c" args="(std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;states, std::vector&lt; double &gt; &amp;rewards)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::absGetRewards </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rewards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">states</td><td>the vector of <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability to be evaluated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rewards</td><td>the returned vector of probability-weighted rewards corresponding to <em>states</em> </td></tr>
  </table>
  </dd>
</dl>
<p>The rewards in rewards are already multiplied by the probabilities of the states. </p>

</div>
</div>
<a class="anchor" id="a68efdbda53b9f30170972cbbaf938f6f"></a><!-- doxytag: member="Maze::absVirtualDynamics" ref="a68efdbda53b9f30170972cbbaf938f6f" args="(const long currAbsState, const long hAct, const long aAct, sparseStateBelief &amp;tranProb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Maze::absVirtualDynamics </td>
          <td>(</td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>currAbsState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>hAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>aAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sparseStateBelief &amp;&#160;</td>
          <td class="paramname"><em>tranProb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Implements the dynamics of this <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a>, with abstraction flag on. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reward of taking current action in current state for current world </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currAbsState</td><td>Current virtual world's state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hAct</td><td>Current Human action </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aAct</td><td>Current AI action </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tranProb</td><td>Sparse representation of next abstract state probabilities given current state and current actions. Note that tranProb should be kept sorted ordered by stateNum (first param) WHY???</td></tr>
  </table>
  </dd>
</dl>
<p>TODO: check world type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tranProb</td><td>vector of pair&lt;next abs state, prob&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>expected reward (analytically) </dd></dl>

</div>
</div>
<a class="anchor" id="aac1040df91de649d968d38d4e0f91008"></a><!-- doxytag: member="Maze::agentMoveCanBeBlocked" ref="aac1040df91de649d968d38d4e0f91008" args="(const AbstractState &amp;currAbsState, int agentIndex, long nextRegion, bool movingTowardsMonster)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Maze::agentMoveCanBeBlocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>currAbsState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nextRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>movingTowardsMonster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used in Planning. Checks whether the agent's movement into <em>nextRegion</em> is blocked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currAbsState</td><td>the current AbtractState </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agentIndex</td><td>0 = Human, 1 = Assistant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nextRegion</td><td>the region in question </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">movingTowardsMonster</td><td>true if this agent is moving towards the monster. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the agent's move is guaranteed not blocked, 1 if it might be blocked and 2 if it is definitely blocked. </dd></dl>

</div>
</div>
<a class="anchor" id="a1850c647d8c03fdf06a0bfc9d32f2466"></a><!-- doxytag: member="Maze::checkVisibility" ref="a1850c647d8c03fdf06a0bfc9d32f2466" args="(long p1X, long p1Y, long p2X, long p2Y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Maze::checkVisibility </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p1X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p1Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p2X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p2Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if coord position p1 sees p2. </dd></dl>

</div>
</div>
<a class="anchor" id="aecf1d96665fc5f90c813081422e3a9d3"></a><!-- doxytag: member="Maze::constructCollabQFns" ref="aecf1d96665fc5f90c813081422e3a9d3" args="(vector&lt; vector&lt; vector&lt; pair&lt; long, double &gt; &gt; &gt; &gt; &amp;transitionMatrix, vector&lt; vector&lt; double &gt; &gt; &amp;rewardMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::constructCollabQFns </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; vector&lt; pair&lt; long, double &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transitionMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rewardMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs Q functions using previously computed transition and reward matrices. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transitionMatrix</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rewardMatrix</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23923e22f02f606083faa3bf174cd9a8"></a><!-- doxytag: member="Maze::constructTRCompAct" ref="a23923e22f02f606083faa3bf174cd9a8" args="(vector&lt; vector&lt; vector&lt; pair&lt; long, double &gt; &gt; &gt; &gt; &amp;transitionMatrix, vector&lt; vector&lt; double &gt; &gt; &amp;rewardMatrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::constructTRCompAct </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; vector&lt; pair&lt; long, double &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>transitionMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rewardMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs transition and reward matrices by invoking a lot of absVirtualDynamics, depending on <em>useAbstract</em> flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">transitionMatrix</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rewardMatrix</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a490975a4d6559bffc844522c04b662cb"></a><!-- doxytag: member="Maze::constructVisibleNearbyRegion" ref="a490975a4d6559bffc844522c04b662cb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::constructVisibleNearbyRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs visible nearby region <em>visibleNearByRegions</em>. This is used to track when the agents move to a region that is visible to the NPC. </p>

</div>
</div>
<a class="anchor" id="a012aa15e27d9fd08385b95276eee6f8d"></a><!-- doxytag: member="Maze::copyInfoFrom" ref="a012aa15e27d9fd08385b95276eee6f8d" args="(Maze *orig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Maze::copyInfoFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies uninitialized data from another maze. In this base class, there is only visionLimit copied. </p>

<p>Reimplemented in <a class="el" href="class_g_b___fiery_maze.html#af70149abac1bc884a57fbebdb503a9d2">GB_FieryMaze</a>, and <a class="el" href="class_g_b___sheep_maze.html#a54e5a1a30f0c1cde809a22630b0ddacd">GB_SheepMaze</a>.</p>

</div>
</div>
<a class="anchor" id="a594b318e6608e5c207501fccf9229a27"></a><!-- doxytag: member="Maze::copyStateMap" ref="a594b318e6608e5c207501fccf9229a27" args="(Maze *orig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::copyStateMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy state maps from another maze. Help avoid reconstruction of state maps multiple times. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">orig</td><td>the maze to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a299ec6938f6a365494ded81ba0ec8c27"></a><!-- doxytag: member="Maze::copyValueQFns" ref="a299ec6938f6a365494ded81ba0ec8c27" args="(Maze *orig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::copyValueQFns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_maze.html">Maze</a> *&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies Q and value functions from another maze. <em>Note:</em> I don't think we need to copy valueFn, or use valueFn for that matter, after Q function is constructed. In the future, I will remove valueFn altogether. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">orig</td><td>the maze to be copied from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab23fb7d220e07119cd763735123823a1"></a><!-- doxytag: member="Maze::deleteCommonPointers" ref="ab23fb7d220e07119cd763735123823a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::deleteCommonPointers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This cleans up the common assets such as state maps and value/q functions. Should only be called on original worlds. </p>

</div>
</div>
<a class="anchor" id="ac51732446025fe4e5f483a9141a7bee6"></a><!-- doxytag: member="Maze::distance_farthestFromBoth" ref="ac51732446025fe4e5f483a9141a7bee6" args="(long monsterNode, long nearestAgentNode, unsigned nearestAgentIndex, long fartherAgentNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Maze::distance_farthestFromBoth </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>nearestAgentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nearestAgentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>fartherAgentNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Individual monster classes can extend these functions to use. Implements the distance function used in <a class="el" href="class_monster.html#a98aaab6b143edac1fa79f26697d83e39">Monster::moveActsFarthestFromBothPlayers</a>. Child classes can customize this function to suit their needs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterNode</td><td>the NPC's gridNodeLabel (integer representation of grid square.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nearestAgentNode</td><td>the nearest agent's gridNodeLabel (integer representation of grid square.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fartherAgentNode</td><td>the farther agent's gridNodeLabel (integer representation of grid square.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance value. </dd></dl>

<p>Reimplemented in <a class="el" href="class_g_b___fiery_maze.html#a5fae045ecc5447cd60e327ca83bbd04c">GB_FieryMaze</a>, and <a class="el" href="class_g_b___sheep_maze.html#add28609030a5bbdd98f80d38ab94d1f6">GB_SheepMaze</a>.</p>

</div>
</div>
<a class="anchor" id="a42a5f75698b89caeabee6c6765ddb71b"></a><!-- doxytag: member="Maze::distance_farthestFromPlayer" ref="a42a5f75698b89caeabee6c6765ddb71b" args="(long monsterNode, long agentNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Maze::distance_farthestFromPlayer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>agentNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Implements the distance function used in <a class="el" href="class_monster.html#ac3697af26cb14c9d6d95f0972dc0697d">Monster::moveActsFarthestFromPlayer</a>. Child classes can customize this function to suit their needs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterNode</td><td>the NPC's gridNodeLabel (integer representation of grid square.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agentNode</td><td>the targeted agent's gridNodeLabel (integer representation of grid square.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance value. </dd></dl>

<p>Reimplemented in <a class="el" href="class_g_b___fiery_maze.html#afeab9e75a17f1365539dde466b67a262">GB_FieryMaze</a>, and <a class="el" href="class_g_b___sheep_maze.html#afd99bdc854daf416915eafb8908d0b70">GB_SheepMaze</a>.</p>

</div>
</div>
<a class="anchor" id="a229ae798c8faa1b4cb1cabd7a1db8e43"></a><!-- doxytag: member="Maze::distance_towardsNode" ref="a229ae798c8faa1b4cb1cabd7a1db8e43" args="(long monsterNode, long destNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Maze::distance_towardsNode </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>destNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Implements the distance function used to calculate the movement that gets NPC closer to <em>destNode</em>. Child classes can customize this function to suit their needs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterNode</td><td>the NPC's gridNodeLabel (integer representation of grid square.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destNode</td><td>the targeted gridNodeLabel (integer representation of grid square.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance value. </dd></dl>

<p>Reimplemented in <a class="el" href="class_g_b___fiery_maze.html#ad0619a8f157ca1138d4ba9950f4644ff">GB_FieryMaze</a>.</p>

</div>
</div>
<a class="anchor" id="ad93ee481e3535e8cccaa979c691ad6a7"></a><!-- doxytag: member="Maze::enumerateLocationOneAgent" ref="ad93ee481e3535e8cccaa979c691ad6a7" args="(std::vector&lt; AbstractState &gt; &amp;input, std::vector&lt; AbstractState &gt; &amp;output, long agentIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::enumerateLocationOneAgent </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>agentIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumerates <em>agentIndex's</em> visibility and coords where appropriate, e.g. when it is in the <em>visionLimit</em> of monster. Optimization - Can enumerate in place? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>the input vector of <a class="el" href="struct_abstract_state.html">AbstractState</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the output vector of <a class="el" href="struct_abstract_state.html">AbstractState</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agentIndex</td><td>the index of the agent. humanIndex is 0, aiIndex is 1.</td></tr>
  </table>
  </dd>
</dl>
<p>Enumerate human and ai's visibility and coords where appropriate, e.g. in the same region as monster.</p>
<p>humanIndex is 0, aiIndex is 1</p>
<p>Optimization - Can enumerate in place? </p>

</div>
</div>
<a class="anchor" id="a1970ceac5e6241498202e3c5f1c638e5"></a><!-- doxytag: member="Maze::executeMazeDynamics" ref="a1970ceac5e6241498202e3c5f1c638e5" args="(State &amp;nextState, int worldNum, RandSource &amp;randSource)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Maze::executeMazeDynamics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>nextState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>worldNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_rand_source.html">RandSource</a> &amp;&#160;</td>
          <td class="paramname"><em>randSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called in <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. Normally this is where maze's status, anything unrelated to <a class="el" href="class_monster.html" title="Base class of all NPCs.">Monster</a> and <a class="el" href="class_special_location.html">SpecialLocation</a>, gets updated. </p>

</div>
</div>
<a class="anchor" id="ad01dcc9c8b75f3b3cb279b6e290e6984"></a><!-- doxytag: member="Maze::generateAbstractStateMap" ref="ad01dcc9c8b75f3b3cb279b6e290e6984" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::generateAbstractStateMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates the abstract state maps.</p>
<p>Note: In absMoveOneAgent, when an agent cross region, if there is no monster in that region, its coords is set to the representative coords of that region. </p>

</div>
</div>
<a class="anchor" id="a6f1bd9b86709c45ebfa40cc7c707b595"></a><!-- doxytag: member="Maze::generateModel" ref="a6f1bd9b86709c45ebfa40cc7c707b595" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::generateModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assumption: There are only corridors and junctions in the map (1.5 dimensions) In solver, if generateModel is called with abstract flag on, V and Q functions store values of <a class="el" href="struct_abstract_state.html">AbstractState</a>. If generateModel is called, V and Q functions store values of normal <a class="el" href="struct_state.html">State</a>.</p>
<p>Assumption: There are only corridors and junctions in the map (1.5 dimensions) In solver, if generateModel is called with abstract flag on, V and Q functions store values of abstract states. If generateModel is called, V and Q functions store values of normal states. </p>

</div>
</div>
<a class="anchor" id="a663ec0453a3d58c28a46a67dda427ec1"></a><!-- doxytag: member="Maze::generateRawStateMap" ref="a663ec0453a3d58c28a46a67dda427ec1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::generateRawStateMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates the raw state maps. It is NOT implemented yet. </p>

</div>
</div>
<a class="anchor" id="a6a831f391122630ed45c28ae3926cffc"></a><!-- doxytag: member="Maze::generateStateMap" ref="a6a831f391122630ed45c28ae3926cffc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::generateStateMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates the state maps. It will call generateAbstractStateMap or generateRawStateMap, depending on whether the abstraction flag is set. Generally, there is no reason to call generateRawStateMap. </p>

</div>
</div>
<a class="anchor" id="ae7f88693da4f8a4b926a755f697d01e4"></a><!-- doxytag: member="Maze::getAbstractWorldGeometricInfo" ref="ae7f88693da4f8a4b926a755f697d01e4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::getAbstractWorldGeometricInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets all abstract related geometric attributes to those of <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. These include <em>connectivity</em>, <em>borderLength</em>, <em>regionRepPoint</em>, <em>rType</em>. </p>

</div>
</div>
<a class="anchor" id="a52827542e60ade8c2ef721c6365c864c"></a><!-- doxytag: member="Maze::getCurrState" ref="a52827542e60ade8c2ef721c6365c864c" args="(vector&lt; long &gt; &amp;propertiesState, long newX=&#45;1, long newY=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::getCurrState </td>
          <td>(</td>
          <td class="paramtype">vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>propertiesState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newX</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newY</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked from <a class="el" href="class_maze_world.html#a357d748113ae76399986121386a5f57e">MazeWorld::getCurrState</a>. Fills propertiesState with initial values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">propertiesState</td><td>the property array of this <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newX</td><td>optional coord </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newY</td><td>optional coord </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a040e8febbd660395ab8c7b0cda402c17"></a><!-- doxytag: member="Maze::getLongAbsStateFromState" ref="a040e8febbd660395ab8c7b0cda402c17" args="(const State &amp;state, long worldNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Maze::getLongAbsStateFromState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>worldNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the index (integer representation) of <a class="el" href="struct_abstract_state.html">AbstractState</a> given <a class="el" href="struct_state.html">State</a> and maze's index. Individual elements of absState are constructed, then getLongFromAbsState is invoked to get long abs state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>the queried state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">worldNum</td><td>the index of this <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> in MazeWorld's array of Mazes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaba3872810abc714f32b59c7ae997eaa"></a><!-- doxytag: member="Maze::getLongFromAbsState" ref="aaba3872810abc714f32b59c7ae997eaa" args="(AbstractState &amp;absState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Maze::getLongFromAbsState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>absState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the long index (integer equivalence) of <a class="el" href="struct_abstract_state.html">AbstractState</a> <em>abState</em> </p>

</div>
</div>
<a class="anchor" id="abeea7864b896d38ce3be729ca4ab69dc"></a><!-- doxytag: member="Maze::getMaxReward" ref="abeea7864b896d38ce3be729ca4ab69dc" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Maze::getMaxReward </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get maximum reward achievable in one time step </p>

<p>Implemented in <a class="el" href="class_g_b___fiery_maze.html#abbf6f8a622e4af910bd6716ba1794816">GB_FieryMaze</a>, <a class="el" href="class_g_b___ghost_maze.html#ac17fc804764395007cc880eaf70feb47">GB_GhostMaze</a>, and <a class="el" href="class_g_b___sheep_maze.html#a3ede1a84470fca2964db9a0a3baf026b">GB_SheepMaze</a>.</p>

</div>
</div>
<a class="anchor" id="adbdd38dc460f86fb2faa99729609271b"></a><!-- doxytag: member="Maze::getMinReward" ref="adbdd38dc460f86fb2faa99729609271b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Maze::getMinReward </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>get minimum reward achievable in one time step. Note that this getMinReward is self-contained, i.e., does not account for min rewards caused by interactions. </p>

<p>Implemented in <a class="el" href="class_g_b___fiery_maze.html#a906318d2405c4087165fc5499aa7fc5b">GB_FieryMaze</a>, <a class="el" href="class_g_b___ghost_maze.html#a94308f0cfbfe3ca3399595e24101e9a7">GB_GhostMaze</a>, and <a class="el" href="class_g_b___sheep_maze.html#a8bd68393cf28f122b1a78011486f3f01">GB_SheepMaze</a>.</p>

</div>
</div>
<a class="anchor" id="a621e75ca6a010fc584d86b33c3847d76"></a><!-- doxytag: member="Maze::getRawWorldGeometricInfo" ref="a621e75ca6a010fc584d86b33c3847d76" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::getRawWorldGeometricInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets all basic geometric attributes to those of <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. These include <em>grid</em>, <em>gridNodeLabel</em>, <em>numAccessibleLocs</em>. Besides, it also invokes <a class="el" href="class_agent.html#af4148e72e6f63a621b574d68accb0f2a">Monster::calcShortestPathMatrix</a>. </p>

</div>
</div>
<a class="anchor" id="aaaa9a56eb59f44119996b871d366bcd7"></a><!-- doxytag: member="Maze::getReward" ref="aaaa9a56eb59f44119996b871d366bcd7" args="(const State &amp;state, bool &amp;vTerminal, int worldNum)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Maze::getReward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>vTerminal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>worldNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used for In-game. Returns the reward of <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> <em>worldNum</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>current <a class="el" href="struct_state.html">State</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vTerminal</td><td>true if <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> <em>worldNum</em> is terminal and false otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">worldNum</td><td>the index of this <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> in MazeWorld's array of Mazes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reward of <a class="el" href="struct_state.html">State</a> <em>state</em>. </dd></dl>

<p>Implemented in <a class="el" href="class_g_b___fiery_maze.html#a989c02b6727cd44500eceb25d6aef88a">GB_FieryMaze</a>, <a class="el" href="class_g_b___ghost_maze.html#abbf1cc82e6e9806fc4744c8f4fd4ea72">GB_GhostMaze</a>, and <a class="el" href="class_g_b___sheep_maze.html#a432600af9aa5fc7c04f3208201e85424">GB_SheepMaze</a>.</p>

</div>
</div>
<a class="anchor" id="a72e26103733a454600dccb1f69538136"></a><!-- doxytag: member="Maze::hasMonster" ref="a72e26103733a454600dccb1f69538136" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Maze::hasMonster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks whether this maze has a monster. A <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> could have at most one <a class="el" href="class_monster.html" title="Base class of all NPCs.">Monster</a> and one <a class="el" href="class_special_location.html">SpecialLocation</a>, and at least one of the above. </p>

</div>
</div>
<a class="anchor" id="a00b218f33aa3cc740e7e2493ad86df57"></a><!-- doxytag: member="Maze::isAbstractTerminal" ref="a00b218f33aa3cc740e7e2493ad86df57" args="(const AbstractState &amp;absState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Maze::isAbstractTerminal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>absState</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if <a class="el" href="struct_abstract_state.html">AbstractState</a> <em>absState</em> is terminal, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a6e2493acfaf338f6af8df6f51475bf35"></a><!-- doxytag: member="Maze::isLocalTermState" ref="a6e2493acfaf338f6af8df6f51475bf35" args="(const State &amp;state, long worldNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Maze::isLocalTermState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>worldNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Just check the subworld itself, does not care about the global state. </p>

</div>
</div>
<a class="anchor" id="a8513ff87aac2b6a27af95aa39efcc2a3"></a><!-- doxytag: member="Maze::isTermState" ref="a8513ff87aac2b6a27af95aa39efcc2a3" args="(const State &amp;state, long worldNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Maze::isTermState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>worldNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if <a class="el" href="struct_state.html">State</a> <em>state</em> is terminal, false otherwise.</p>
<p>A maze's state is terminal if either the full state was set to terminal or itself was set to terminal. </p>

</div>
</div>
<a class="anchor" id="a538506a9125120ac5b220b96b5db0939"></a><!-- doxytag: member="Maze::isValidMove" ref="a538506a9125120ac5b220b96b5db0939" args="(int agentIndex, long tempX, long tempY, long otherAgentX, long otherAgentY, const AbstractState &amp;currState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Maze::isValidMove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tempX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tempY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>otherAgentX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>otherAgentY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine is used when planning is done without abstraction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the proposed new coordinates of player <em>agentIndex</em> (<em>tempX</em>, <em>tempY</em>) are valid with respect to blocking conditions. </dd></dl>

</div>
</div>
<a class="anchor" id="a8683206f101059ba94b0fc4d938b6593"></a><!-- doxytag: member="Maze::playerPassable" ref="a8683206f101059ba94b0fc4d938b6593" args="(int agentIndex, long regionIndex, int monsterX=&#45;1, int monsterY=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Maze::playerPassable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>regionIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>monsterX</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>monsterY</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns true if the agent in question can enter region in question. Note that since we force special locations to be junctions, thereby a region on its own, this suffices. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">agentIndex</td><td>0 = Human, 1 = Assistant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regionIndex</td><td>the region in question. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9da719edbff6ad0914577ce7f3cfdd25"></a><!-- doxytag: member="Maze::realToVirtual" ref="a9da719edbff6ad0914577ce7f3cfdd25" args="(const State &amp;currState, const long worldNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Maze::realToVirtual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_state.html">State</a> &amp;&#160;</td>
          <td class="paramname"><em>currState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>worldNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts <a class="el" href="struct_state.html">State</a> to <a class="el" href="struct_abstract_state.html">AbstractState</a> w.r.t <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> <em>worldNum</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currState</td><td>current <a class="el" href="struct_state.html">State</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">worldNum</td><td>the index of this <a class="el" href="class_maze.html" title="This class is the base class for all individual tasks/puzzles that the protagonists need to solve in ...">Maze</a> in MazeWorld's array of Mazes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>long <a class="el" href="struct_abstract_state.html">AbstractState</a> if useAbstract, long virtual <a class="el" href="struct_state.html">State</a> otherwise.</dd>
<dd>
long absState if useAbstract, long virtual state otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a34075ab43d867af376a9c03101909e97"></a><!-- doxytag: member="Maze::regionVisible" ref="a34075ab43d867af376a9c03101909e97" args="(long monsterGridNode, long region)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Maze::regionVisible </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterGridNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks whether <em>region</em> is visible from <em>monsterGridNode</em>. If yes, the returned value denotes the number of grid nodes in <em>region</em> that are visible from <em>monsterGridNode</em>. Otherwise, it is 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterGridNode</td><td>the NPC's gridNodeLabel (integer representation of grid square.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">region</td><td>the region in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of grid nodes in region that are visible from monsterGridNode</dd>
<dd>
the number of grid squares in region that can be seen from monsterGridNode </dd></dl>

</div>
</div>
<a class="anchor" id="ab120d8936edd497ab60cb4cab9f5ae9f"></a><!-- doxytag: member="Maze::setAssistant" ref="ab120d8936edd497ab60cb4cab9f5ae9f" args="(Player *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::setAssistant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_player.html">Player</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets Assistant pointer. </p>

</div>
</div>
<a class="anchor" id="a27ea32d74669448a505d958bea501b4f"></a><!-- doxytag: member="Maze::setHuman" ref="a27ea32d74669448a505d958bea501b4f" args="(Player *h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::setHuman </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_player.html">Player</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets Human pointer. </p>

</div>
</div>
<a class="anchor" id="a4f3fff84acdcbe1059388b5c3d58a9cf"></a><!-- doxytag: member="Maze::setPlayers" ref="a4f3fff84acdcbe1059388b5c3d58a9cf" args="(Player *h, Player *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::setPlayers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_player.html">Player</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_player.html">Player</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets both <a class="el" href="class_player.html" title="Base class of individual game&#39;s Human and AiAssistant.">Player</a> and Assistant. </p>

</div>
</div>
<a class="anchor" id="a91c5ba1ff1e4da448a91c91d3cbf64b6"></a><!-- doxytag: member="Maze::setProperty" ref="a91c5ba1ff1e4da448a91c91d3cbf64b6" args="(string pName, string pValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Maze::setProperty </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets property <em>pName</em> to corresponding value <em>pValue</em>. This routine is empty in this base class; child classes should set <em>pName</em> properly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pName</td><td>property's name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pValue</td><td>property's value </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_g_b___fiery_maze.html#a2c909dd46c4ef6bfb2ab55da97b892d5">GB_FieryMaze</a>, <a class="el" href="class_g_b___ghost_maze.html#a0d75bbda78222acd7812969f6dec1a44">GB_GhostMaze</a>, and <a class="el" href="class_g_b___sheep_maze.html#adbd4ee9e626281ca265de05274945e26">GB_SheepMaze</a>.</p>

</div>
</div>
<a class="anchor" id="aea18278fd9f757cde5af37088c5008bb"></a><!-- doxytag: member="Maze::setUseAbstract" ref="aea18278fd9f757cde5af37088c5008bb" args="(bool uA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::setUseAbstract </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uA</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets abstract flag. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uA</td><td>if uA = true, this maze is planned using abstraction. Otherwise, uses raw <a class="el" href="struct_state.html">State</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab53296e217e438d104b28bccbf6fab2b"></a><!-- doxytag: member="Maze::standardizeCoords" ref="ab53296e217e438d104b28bccbf6fab2b" args="(AbstractState &amp;absState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::standardizeCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>absState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Standardizes agents' coordinates. After all movements have been made, the agents' coordinates reflect the direction from which they move, which creates non-standard <a class="el" href="struct_abstract_state.html">AbstractState</a>. This routine fixes that. </p>

</div>
</div>
<a class="anchor" id="a4c80a0e66de89f9638e16f6f83c115e9"></a><!-- doxytag: member="Maze::towardsTheOther" ref="a4c80a0e66de89f9638e16f6f83c115e9" args="(long p1X, long p1Y, long action, long p2X, long p2Y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Maze::towardsTheOther </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p1X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p1Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p2X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>p2Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if critter 1 at p1 executing <em>action</em> moves towards critter 2 at p2. This routine is called when a critter's action has already been verified to move it to another grid square. </p>

</div>
</div>
<a class="anchor" id="a86a66c879b97c18d459e39c7b56e974c"></a><!-- doxytag: member="Maze::updateCoords" ref="a86a66c879b97c18d459e39c7b56e974c" args="(AbstractState &amp;nextAbsState, int movingAgent, long action, long monsterRegion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::updateCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>nextAbsState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>movingAgent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called when a Human/Assistant has just crossed a border to a new region. This routine will update the coords of the moving agent. Using regionRepPoint and borderLength (the length of each region) to compute the region's point that indicates from which side of a region the agent has just come from when entering monster's region.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">nextAbsState</td><td>the <a class="el" href="struct_abstract_state.html">AbstractState</a> to be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">movingAgent</td><td>the index of the agent that moves. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>the movement action of the agent in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterRegion</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67f7131e08c547ee5223d16f9bc42178"></a><!-- doxytag: member="Maze::updateCoordsByMonsterMove" ref="a67f7131e08c547ee5223d16f9bc42178" args="(AbstractState &amp;absState, long monsterAct, long priorMonsterRegion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::updateCoordsByMonsterMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>absState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>priorMonsterRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates agents' coordinates to reflect their relative position with NPC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">absState</td><td>the <a class="el" href="struct_abstract_state.html">AbstractState</a> to be updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterAct</td><td>NPC's movement act. It is already checked to be anything but unchanged. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priorMonsterRegion</td><td>NPC's region before making the move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0034a3c99a5c1786038e91db358f61ef"></a><!-- doxytag: member="Maze::updateVisibility" ref="a0034a3c99a5c1786038e91db358f61ef" args="(AbstractState &amp;absState, std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;output, long humanAct, long aiAct, long monsterAct, long priorMonsterX, long priorMonsterY, const AbstractState &amp;prevAbsState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::updateVisibility </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>absState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>humanAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>aiAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>priorMonsterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>priorMonsterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>prevAbsState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Based on the actions executed by monster and Human/Assistant, updates the visibility and coordinates of Human and agent in <em>absState</em>, which possibly spawns new abstract states stored in tempOutput. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">absState</td><td>the prior <a class="el" href="struct_abstract_state.html">AbstractState</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the vector of posterior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">humanAct</td><td>action of Human. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aiAct</td><td>action of Assistant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterAct</td><td>action of NPC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priorMonsterX</td><td>prior coordinate X of NPC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priorMonsterY</td><td>prior coordinate Y of NPC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevAbsState</td><td>the <a class="el" href="struct_abstract_state.html">AbstractState</a> prior to applying <em>humanAct</em>, <em>aiAct</em> and <em>monsterAct</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00bd84c680addfec42ce730db3ae336e"></a><!-- doxytag: member="Maze::updateVisibility_NoAbs" ref="a00bd84c680addfec42ce730db3ae336e" args="(AbstractState &amp;absState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::updateVisibility_NoAbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>absState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Based on the exact coords of monster and players to update monster's visibility. </p>

</div>
</div>
<a class="anchor" id="abf30f7c50f0083e729181f2bb0789335"></a><!-- doxytag: member="Maze::updateVisibilityCoordsOneAgent" ref="abf30f7c50f0083e729181f2bb0789335" args="(std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;input, std::vector&lt; std::pair&lt; AbstractState, double &gt; &gt; &amp;output, long monsterAct, long priorMonsterX, long priorMonsterY, long agentAct, int agentIndex, const AbstractState &amp;prevAbsState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Maze::updateVisibilityCoordsOneAgent </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="struct_abstract_state.html">AbstractState</a>, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>monsterAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>priorMonsterX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>priorMonsterY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>agentAct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_abstract_state.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>prevAbsState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates visibility and coords of <em>agentIndex</em> after NPC has made its move <em>monsterAct</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>the vector of prior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>the vector of posterior <a class="el" href="struct_abstract_state.html">AbstractState</a> with probability. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">monsterAct</td><td>movement action of NPC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priorMonsterX</td><td>prior coordinate X of NPC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priorMonsterY</td><td>prior coordinate Y of NPC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agentAct</td><td>action of the agent in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agentIndex</td><td>0 = Human, 1 = Assistant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prevAbsState</td><td>the <a class="el" href="struct_abstract_state.html">AbstractState</a> prior to applying <em>humanAct</em> and <em>aiAct</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>Update visibility and coords of agentIndex </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aabbd7a095b01ffbaf0aaa28b4bc2db8c"></a><!-- doxytag: member="Maze::borderLength" ref="aabbd7a095b01ffbaf0aaa28b4bc2db8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector &lt;long&gt; &gt;* <a class="el" href="class_maze.html#aabbd7a095b01ffbaf0aaa28b4bc2db8c">Maze::borderLength</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the game's borderLength, previously constructed in <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. </p>

</div>
</div>
<a class="anchor" id="a80372d46277e64e72157e2bc0c59bc36"></a><!-- doxytag: member="Maze::collabQFn" ref="a80372d46277e64e72157e2bc0c59bc36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector &lt;double&gt; &gt;* <a class="el" href="class_maze.html#a80372d46277e64e72157e2bc0c59bc36">Maze::collabQFn</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the Q function of this maze. If this is an original maze, <em>collabQFn</em> is allocated here, and should be deallocated by this maze as well. </p>

</div>
</div>
<a class="anchor" id="ae9415e8201667a551ed7d1aa21ad9dce"></a><!-- doxytag: member="Maze::connectivity" ref="ae9415e8201667a551ed7d1aa21ad9dce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector &lt;long&gt; &gt;* <a class="el" href="class_maze.html#ae9415e8201667a551ed7d1aa21ad9dce">Maze::connectivity</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the game's connectivity, previously constructed in <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. </p>

</div>
</div>
<a class="anchor" id="a43258bc77fe635c3dea20ab04900fb2b"></a><!-- doxytag: member="Maze::grid" ref="a43258bc77fe635c3dea20ab04900fb2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector &lt;long&gt; &gt;* <a class="el" href="class_maze.html#a43258bc77fe635c3dea20ab04900fb2b">Maze::grid</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the game's grid, previously constructed in <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. </p>

</div>
</div>
<a class="anchor" id="a00d2c4057ffa2132623c0badd91312a1"></a><!-- doxytag: member="Maze::gridNodeLabel" ref="a00d2c4057ffa2132623c0badd91312a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector &lt;long&gt; &gt;* <a class="el" href="class_maze.html#a00d2c4057ffa2132623c0badd91312a1">Maze::gridNodeLabel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the game's gridNodeLabel, previously constructed in <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. </p>

</div>
</div>
<a class="anchor" id="a358e7b04077b94e6a32e346e285a3ce8"></a><!-- doxytag: member="Maze::mazeWorld" ref="a358e7b04077b94e6a32e346e285a3ce8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_maze_world.html">MazeWorld</a>* <a class="el" href="class_maze.html#a358e7b04077b94e6a32e346e285a3ce8">Maze::mazeWorld</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The parent game level. </p>

</div>
</div>
<a class="anchor" id="ab612d9b5fe88c95d25cde4cd01cfb5b5"></a><!-- doxytag: member="Maze::monster" ref="ab612d9b5fe88c95d25cde4cd01cfb5b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_monster.html">Monster</a>* <a class="el" href="class_maze.html#ab612d9b5fe88c95d25cde4cd01cfb5b5">Maze::monster</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>monster</em> can be null. if it's null, this world just has special locations and/or items. </p>

</div>
</div>
<a class="anchor" id="a1c544bba62b98fb6ae13817d1fc3fa50"></a><!-- doxytag: member="Maze::numAccessibleLocs" ref="a1c544bba62b98fb6ae13817d1fc3fa50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_maze.html#a1c544bba62b98fb6ae13817d1fc3fa50">Maze::numAccessibleLocs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of accessible grid squares. </p>

</div>
</div>
<a class="anchor" id="aa89eedef611d421e299676e8dfa7a589"></a><!-- doxytag: member="Maze::player" ref="aa89eedef611d421e299676e8dfa7a589" args="[2]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_player.html">Player</a>* <a class="el" href="class_maze.html#aa89eedef611d421e299676e8dfa7a589">Maze::player</a>[2]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the <a class="el" href="class_player.html" title="Base class of individual game&#39;s Human and AiAssistant.">Player</a> objects. </p>

</div>
</div>
<a class="anchor" id="a0ae65512cb2e896861d1e38de432b30b"></a><!-- doxytag: member="Maze::regionRepPoint" ref="a0ae65512cb2e896861d1e38de432b30b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt;long, long&gt; &gt;* <a class="el" href="class_maze.html#a0ae65512cb2e896861d1e38de432b30b">Maze::regionRepPoint</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the game's regionRepPoint, previously constructed in <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. </p>

</div>
</div>
<a class="anchor" id="a768366ad0e8deb6fd4c7008be57bd0f5"></a><!-- doxytag: member="Maze::reverseVAbsStateMap" ref="a768366ad0e8deb6fd4c7008be57bd0f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="struct_abstract_state.html">AbstractState</a>&gt;* <a class="el" href="class_maze.html#a768366ad0e8deb6fd4c7008be57bd0f5">Maze::reverseVAbsStateMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maps from <em>index</em> to <a class="el" href="struct_abstract_state.html">AbstractState</a>. This is only constructed if the maze is solved with abstraction. </p>

</div>
</div>
<a class="anchor" id="a69c4f5c810cd2ab5a60ce13b919b1c47"></a><!-- doxytag: member="Maze::rType" ref="a69c4f5c810cd2ab5a60ce13b919b1c47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;regionType&gt;* <a class="el" href="class_maze.html#a69c4f5c810cd2ab5a60ce13b919b1c47">Maze::rType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the game's rType, previously constructed in <a class="el" href="class_maze_world.html" title="This class is the base class for a game&#39;s level in which the protagonists need to solve puzzles t...">MazeWorld</a>. </p>

</div>
</div>
<a class="anchor" id="acf2dd7249500505fc6f4a05bd0cd53af"></a><!-- doxytag: member="Maze::specialLocation" ref="acf2dd7249500505fc6f4a05bd0cd53af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_special_location.html">SpecialLocation</a>* <a class="el" href="class_maze.html#acf2dd7249500505fc6f4a05bd0cd53af">Maze::specialLocation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_special_location.html">SpecialLocation</a> is not shared among mazes of the same type. Shared special locations/items should be represented by other means. </p>

</div>
</div>
<a class="anchor" id="a465cff1bcf4083a4a1c4ea782066d4a6"></a><!-- doxytag: member="Maze::useAbstract" ref="a465cff1bcf4083a4a1c4ea782066d4a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_maze.html#a465cff1bcf4083a4a1c4ea782066d4a6">Maze::useAbstract</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Abstraction flag. </p>

</div>
</div>
<a class="anchor" id="a47e9bef9633745c37f9565ee002f8bbd"></a><!-- doxytag: member="Maze::vAbsStateMap" ref="a47e9bef9633745c37f9565ee002f8bbd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;<a class="el" href="struct_abstract_state.html">AbstractState</a>, long, <a class="el" href="class_utilities_1_1_abstract_state_comparator.html">Utilities::AbstractStateComparator</a>&gt;* <a class="el" href="class_maze.html#a47e9bef9633745c37f9565ee002f8bbd">Maze::vAbsStateMap</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maps from <a class="el" href="struct_abstract_state.html">AbstractState</a> to <em>index</em>. This is only constructed if the maze is solved with abstraction. </p>

</div>
</div>
<a class="anchor" id="a8a46a749b5d1f268e5fb9f7f198d5c8b"></a><!-- doxytag: member="Maze::valueFn" ref="a8a46a749b5d1f268e5fb9f7f198d5c8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;double&gt;* <a class="el" href="class_maze.html#a8a46a749b5d1f268e5fb9f7f198d5c8b">Maze::valueFn</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer to the value function of this maze. If this is an original maze, <em>valueFn</em> is allocated here, and should be deallocated by this maze as well. </p>

</div>
</div>
<a class="anchor" id="a3d78602c03c0d90619fa743c93f1bd96"></a><!-- doxytag: member="Maze::virtualSize" ref="a3d78602c03c0d90619fa743c93f1bd96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_maze.html#a3d78602c03c0d90619fa743c93f1bd96">Maze::virtualSize</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of planned states. </p>

</div>
</div>
<a class="anchor" id="a891498967d3d7be11aeff899854c1fea"></a><!-- doxytag: member="Maze::visibleNearByRegions" ref="a891498967d3d7be11aeff899854c1fea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector &lt; std::pair&lt;long,long&gt; &gt; &gt;* <a class="el" href="class_maze.html#a891498967d3d7be11aeff899854c1fea">Maze::visibleNearByRegions</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Vector of visible nearby regions, indexed by accessible grid node, storing vectors of pair&lt;long, long&gt; (region, numVisibleNodes), indicating the visible nearby regions with number of grid nodes being seen. </p>

</div>
</div>
<a class="anchor" id="a7cb48752d0b97561eb7eba4c01cd6f54"></a><!-- doxytag: member="Maze::visionLimit" ref="a7cb48752d0b97561eb7eba4c01cd6f54" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_maze.html#a7cb48752d0b97561eb7eba4c01cd6f54">Maze::visionLimit</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The vision limit of the monster. </p>

</div>
</div>
<a class="anchor" id="a7dd5ff791f5b45cff2a0498763398965"></a><!-- doxytag: member="Maze::worldType" ref="a7dd5ff791f5b45cff2a0498763398965" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_maze.html#a7dd5ff791f5b45cff2a0498763398965">Maze::worldType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Integer identifier for this type of mazes. </p>

</div>
</div>
<a class="anchor" id="a827027dd364807efd8e9875115609ddf"></a><!-- doxytag: member="Maze::worldTypeStr" ref="a827027dd364807efd8e9875115609ddf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="class_maze.html#a827027dd364807efd8e9875115609ddf">Maze::worldTypeStr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>String identifier for this type of mazes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>WorldModels/<a class="el" href="_maze_8h_source.html">Maze.h</a></li>
<li>WorldModels/Maze.cc</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_maze.html">Maze</a>      </li>
      <li class="footer">Generated on Fri Jun 8 2012 01:14:50 for CAPIRSolver by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
